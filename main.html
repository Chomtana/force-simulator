<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="stylesheet" href="script/context.css">
	<link rel="stylesheet" href="script/jquery-ui/jquery-ui.min.css">
	<link rel="stylesheet" href="css/main-font-face.css">
	<link rel="stylesheet" href="css/main.css">
	<link rel="shortcut icon" href="images/icon.ico">
	<script src="script/jquery.js"></script>
	<script src="script/context.js"></script>
    <script src="script/kinetic.js"></script>
	<!--<script src="script/jquery.mobile.js"></script>-->
	<script src="script/math.js"></script>
	<script src="script/jquery-ui/jquery-ui.min.js"></script>
	<script src="script/Highcharts/js/highcharts.js"></script>
<title>สื่อจำลองการทำงานของเครื่องกล</title>
</head>
<body>
	 <div id="toptoolbar">
    	<table border="0" cellspacing="0" cellpadding="0">
        	<tr>
            	<td>
                    <div class="toolbarbutton runbutton" onClick="run();" title="เริ่มการจำลอง">
						<div style="background-image: url(images/toptoolbar/start.png); width:100%; height:100%;"></div>
                    </div>
            	</td>
                <!--<td>
                    <div class="toolbarbutton runonly pausebutton" onclick="pause();">
						<div style="background-image: url(images/toptoolbar/pause.png); width:100%; height:100%;"></div>
                    </div>
                </td>-->
                <td>
                    <div class="toolbarbutton runonly resetbutton" onclick="resetscene();" title="หยุดการจำลอง">
                        <div style="background-image: url(images/toptoolbar/reset.png); width:100%; height:100%;"></div>
                    </div>
                </td>
                <!--<td>
                    <div class="toolbarbutton" onclick="clearscene();" title="ล้างวัตถุ">
                        <div style="background-image: url(images/toptoolbar/eraser.png); width:100%; height:100%;"></div>
                    </div>
                </td>-->
                <td>
                    <div class="toolbarbutton" onclick="openoptiondialog();" title="การตั้งค่า">
                        <div style="background-image: url(images/toptoolbar/option.png); width:100%; height:100%;"></div>
                    </div>
                </td>
                <!--<td>
                    <div class="toolbarbutton" onclick="openchartdialog();" title="แสดงผลเป็นกราฟ">
                        <div style="background-image: url(images/toptoolbar/chart.png); width:100%; height:100%;"></div>
                    </div>
                </td>-->
                <td>
                    <div class="toolbarbutton" onclick="window.location = 'index.html#home';" title="ย้อนกลับ">
                        <div style="background-image: url(images/toptoolbar/back.png); width:100%; height:100%;"></div>
                    </div>
                </td>
			</tr>
		</table>
	 </div>
	<div id="sidetoolbar">
		<!--<div class="toolbarbutton" data-id="0" title="วัตถุ">
             <div style="background-image: url(images/sidetoolbar/object/box.png); width:100%; height:100%;"></div>
		</div>-->
        <div class="toolbarbutton" data-id="1" title="พื้นเอียง">
            <div style="background-image: url(images/sidetoolbar/machinery/floorslide.png); width:100%; height:100%;"></div>
        </div>
        <div class="toolbarbutton" data-id="2" title="คาน">
            <div style="background-image: url(images/sidetoolbar/machinery/beam.png); width:100%; height:100%;"></div>
        </div>
        <div class="toolbarbutton" data-id="3" title="รอก">
            <div style="background-image: url(images/sidetoolbar/machinery/pulley.png); width:100%; height:100%;"></div>
        </div>
        <div class="toolbarbutton" data-id="4" title="ลิ่ม">
            <div style="background-image: url(images/sidetoolbar/machinery/wedge.png); width:100%; height:100%;"></div>
        </div>
        <div class="toolbarbutton" data-id="5" title="ล้อและเพลา">
            <div style="background-image: url(images/sidetoolbar/machinery/wheel.png); width:100%; height:100%;"></div>
        </div>
        <div class="toolbarbutton" data-id="6" title="สกรู">
            <div style="background-image: url(images/sidetoolbar/machinery/screw.png); width:100%; height:100%;"></div>
        </div>
        <!--<div class="toolbarbutton" data-id="7" title="แรง">
            <div style="background-image: url(images/sidetoolbar/force/force.png); width:100%; height:100%;"></div>
        </div>-->
		<!--<div class="toolbarbutton" data-id="8">
			<div style="background-image: url(images/sidetoolbar/force/rope.png); width:100%; height:100%;"></div>
		</div>-->
	</div>
	<div id="mainarea">
		 
	</div>
    <div id="statusbarroot">
        <table>
            <tr>
                <td valign="top">
                    <div id="statusbar">
                        <b>กรุณาเลือกชนิดของเครื่องกลเพื่อทำการจำลอง</b>
                    </div>
                </td>
                <td valign="top">
                    <div id="rulerbar">
                    </div>
                </td>
            </tr>
        </table>
    </div>
	<div id="rulerdialog" class="dialog" title="ความยาว">
		<div style="background-color: #000000">
			<div id="rulercanvas"></div>
			<div id="rulerresult">นำเมาส์ไปวางบนเส้นเพื่อดูความยาว</div>
		</div>
	</div>
	<div id="optiondialog" class="dialog" title="การตั้งค่า">
		<div class="content">
			<b>แรงโน้มถ่วง: </b><input type="text" class="datainput datainputfloat datainputg" value="9.80"> m/s<sup>2</sup><br />
			<b>มาตราส่วน: 1 pixel : </b><input type="text" class="datainput datainputfloat datainputratio" value="0.1"> เมตร<br />
            <b>ตำแหน่งทศนิยม : </b><input type="text" class="datainput datainputfloat datainputdecimalround" value="3"> ตำแหน่ง
		</div>
	</div>
	<div id="chartdialog" class="dialog" title="กราฟ">
		<div id="chart"></div>
	</div>
    <input type="number">
<!-- Rect points: [xmin, ymin, xmin, ymax, xmax, ymax, xmax, ymin] -->
<script>
var g = 9.8;
	
var currenttool = -1;
var currenttooloverride = false;
var currenttoolcallback;
var currenttoolarg;
//var objectid = 0;
var objects = [];
//var activeobj = -1;

var windoww = $(document).innerWidth();
var windowh = $(document).innerHeight();
var stagew = windoww-50;
var stageh = windowh-180;

var mousestartx;
var mousestarty;

var decimalround = 3;
var ondragobj = null;

var optiontemp = {};

var mousedraglayer = new Kinetic.Layer();
mousedraglayer.add(new Kinetic.Line({
    points: [0, 0, 0, 0, 0, 0, 0, 0],
    stroke: '#0000FF',
    strokeWidth: 2,
    closed: true,
    dash: [25, 10]
}));

mousedraglayer.add(new Kinetic.Line({
    points: [0, 0, 0, 0],
    stroke: '#0000FF',
    strokeWidth: 2,
    closed: false,
    dash: [25, 10]
}));

var mousedrageffect = true;

var mousedown = false;

var selectionlayer = new Kinetic.Layer();
selectionlayer.selects = {};
var selected = [];

//var anchorgroup = new Kinetic.Group();
//anchorgroup.anchors = [];
var anchors = [];
var anchorlayers = [];
var anchorondrag = false;
var activeanchor;

var inputtemp;

var pixel2m = 0.1;

var performancetime = 0;

function initsize () {
	windoww = $(document).innerWidth();
	windowh = $(document).innerHeight();
	stagew = windoww-50;
	stageh = windowh-180;
	stage.setWidth(stagew);
	stage.setHeight(stageh);
}

var stage = new Kinetic.Stage({
	container: 'mainarea',
	width: stagew,
	height: stageh
});

//stage add area

stage.add(selectionlayer);
//stage.add(anchorgroup);

//var layer = new Kinetic.Layer();
var floorlayer = new Kinetic.Layer();
var floorlayerline;
var topfloorlayerline;

function caldecimalround (num) {
	if (num == 0) {
		return num.toFixed(decimalround);
	}
	
	var result = 0;
	var current = 1;
	for (i = 0;;i++) {
		if (num*current >= 1 || num*current <= -1) {
			result = i;
			break;
		}
		current *= 10;
	}
	if (result < decimalround) {
		result = decimalround;
	}
	return num.toFixed(result);
	//return result;
}

function arraylengthnn (array) {
	var result = 0;
	$.each(array,function (index,value) {
		if (value != null) {
			result++;
		}
	})
	return result;
}

function engtothaitype (type) {
	switch (type) {
		case "beam":return "คาน"; break;
		case "object":return "วัตถุ"; break;
		case "slide":return "พื้นเอียง"; break;
		case "force":return "แรง"; break;
		case "wedge":return "ลิ่ม"; break;
		case "pulley":return "รอก"; break;
	    case "wheel": return "ล้อและเพลา"; break;
	    case "screw": return "สกรู"; break;
		case "rope":return "เชือก"; break;
		default:return "???"; break;
	}
	return null;
}

function drawfloor () {
	floorlayer.remove();
	floorlayer = new Kinetic.Layer();
	floorlayerline = floorlayer.add(new Kinetic.Line({
		points: [0,stageh-50,stagew,stageh-50],
		stroke: "red",
		strokeWidth: 15
	}));
	topfloorlayerline = floorlayer.add(new Kinetic.Line({
		points: [0,30,stagew,30],
		stroke: "red",
		strokeWidth: 15
	}));
	for (i=0;i<stagew+60;i+=30) {
		floorlayer.add(new Kinetic.Line({
			points: [i,stageh-50,i-30,stageh],
			stroke: "red",
			strokeWidth: 5
		}));
		floorlayer.add(new Kinetic.Line({
			points: [i,-20,i-30,30],
			stroke: "red",
			strokeWidth: 5
		}));
	}
	stage.add(floorlayer);
}

function updateweight (obj,value) {
	obj.weight = value;
	//console.log(obj);
	switch (obj.type) {
		case "object":
			var root = obj.instanceof;
			switch (root.type) {
			    case "beam":
				    var moment = calmoment(root);
				    root.momentr = moment.momentr;
				    root.momentl = moment.momentl;
				break;
			}
			break;
	    case "beam":
	        obj.centerforce.force = value / 1000 * g;

			var moment = calmoment(obj);
			obj.momentr = moment.momentr;
			obj.momentl = moment.momentl;
			break;
		case "rope":
			var root = obj.instanceof;
			switch (root.type) {
				case "pulley":
					if (obj.id == root.leftrope.id) {
						root.rightrope.weight = obj.weight;
					} else if (obj.id == root.rightrope.id) {
						root.leftrope.weight = obj.weight;
					}
					break;
			}
			break;
	}
}

function updatef (obj,value) {
	obj.force = value;
	//console.log(obj);
	var root = obj.instanceof;
	switch (root.type) {
		case "beam": 
		var moment = calmoment(root);
		root.momentr = moment.momentr;
		root.momentl = moment.momentl;
		break;
	}
}

function beamupdatewidth(beam, value) {
    var center = (beam.xmax + beam.xmin) / 2;
    var xmin = center - value / pixel2m / 2;
    var xmax = center + value / pixel2m / 2

    if ((xmax < beam.objcentermax || xmin > beam.objcentermin) && (beam.objcentermax != -1 || beam.objcentermin != -1)) {
        return false;
    } else {
        beam.xmin = center - value / pixel2m / 2;
        beam.xmax = center + value / pixel2m / 2;
        beam.getChildren()[1].points([beam.xmin, beam.ymin, beam.xmin, beam.ymax, beam.xmax, beam.ymax, beam.xmax, beam.ymin]);
        beam.draw();
        beamrotate(beam, 0);
        return true;
    }
}

function beamupdateheight(beam, value) {
    var yold = beam.ymin;
    beam.ymin = beam.ymax - value / pixel2m;

    var ychange = beam.ymin - yold;

    beam.getChildren()[1].points([beam.xmin, beam.ymin, beam.xmin, beam.ymax, beam.xmax, beam.ymax, beam.xmax, beam.ymin]);
    beam.draw();

    //console.log(ychange);

    $.each(beam.objects, function (index, obj) {
        obj.ymin += ychange;
        obj.ymax += ychange;
        obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
        obj.draw();
    });

    beamrotate(beam, 0);
}

function beamupdatebaseheight(beam, value) {
    beam.getChildren()[0].setY((stageh - 60) - (1 / 3 * value / pixel2m));
    beam.getChildren()[0].setRadius(2 / 3 * value / pixel2m);
    beam.draw();

    var h = beam.ymax - beam.ymin;
    beam.ymax = (stageh - 60) - (value / pixel2m);
    beamupdateheight(beam, h * pixel2m);
}

function beamupdatefulcrumpos(beam, value) {
    //100 ... width
    //value ... width/100*value
    var width = beam.xmax - beam.xmin;
    var xplus = width / 100 * value;

    beam.fulcrum = beam.xmin + xplus;
    beam.getChildren()[0].setX(beam.fulcrum);
    beam.draw();
}

function objupdatedfromfulcrum(obj, value) {
    var fulcrum = obj.instanceof.fulcrum;

    obj.xmin = (fulcrum + value / pixel2m) - obj.width / 2;
    obj.xmax = obj.xmin + obj.width;
    obj.center = obj.centerori = (obj.xmax + obj.xmin) / 2;
    obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
    obj.draw();
}

function slideupdateheight(slide, value) {
    var xstart = slide.xstart;
    var ystart = slide.ystart;
    slide.ystart = (stageh - 60) - (value / pixel2m);

    var result = true;

    if (Math.abs(slide.xend - slide.xstart) < 30 || stageh - 60 - slide.ystart < 10) {
        result = false;
    }

    //Update equation and angle
    var angle = slide.angle;
    var equation = slide.equation;
    slide.angle = Math.atan(((stageh - 60) - slide.ystart) / (Math.max(slide.xstart, slide.xend) - Math.min(slide.xstart, slide.xend))) * (180 / Math.PI);
    slide.equation = Math.linearCanvas.create(slide.xstart, slide.ystart, slide.xend, stageh - 60).parallelD(-4);

    if (result) {
        result = updateobjectslidetest(slide);
    }

    if (result) {
        updateobjectslide(slide);
    } else {
        slide.xstart = xstart;
        slide.ystart = ystart;
        slide.angle = angle;
        slide.equation = equation;
    }

    if (result) {
        slide.getChildren()[0].points([slide.xstart, slide.ystart, slide.xstart, stageh - 60, slide.xend, stageh - 60]);
    }

    slide.draw();

    return result;
}

function slideupdatewidth(slide, value) {
    var xend = slide.xend;
    var ystart = slide.ystart;
    slide.xend = slide.xstart + (value / pixel2m);

    //console.log(slide.xend);

    var result = true;

    if (Math.abs(slide.xend - slide.xstart) < 30 || stageh - 60 - slide.ystart < 10) {
        result = false;
    }

    //Update equation and angle
    var angle = slide.angle;
    var equation = slide.equation;
    slide.angle = Math.atan(((stageh - 60) - slide.ystart) / (Math.max(slide.xstart, slide.xend) - Math.min(slide.xstart, slide.xend))) * (180 / Math.PI);
    slide.equation = Math.linearCanvas.create(slide.xstart, slide.ystart, slide.xend, stageh - 60).parallelD(-4);

    if (result) {
        result = updateobjectslidetest(slide);
    }

    if (result) {
        updateobjectslide(slide);
    } else {
        slide.xend = xend;
        slide.ystart = ystart;
        slide.angle = angle;
        slide.equation = equation;
    }

    if (result) {
        slide.getChildren()[0].points([slide.xstart, slide.ystart, slide.xstart, stageh - 60, slide.xend, stageh - 60]);
    }

    console.log((slide.xend-slide.xstart)*pixel2m);

    slide.draw();

    return result;
}

function objslideupdatedfromend(obj, value) {
    setobjectslidepos(obj, value / pixel2m);
}

function objupdatewidth(obj, value) {
    obj.width = value / pixel2m;
    if (obj.instanceof.type != "slide") {
        obj.xmin = obj.center - (value / pixel2m / 2);
        obj.xmax = obj.center + (value / pixel2m / 2);

        obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
        obj.draw();
    } else {
        obj.fire("dragend");
    }
    return true;
}

function objupdateheight(obj, value) {
    obj.height = (obj.height > 0) ? value / pixel2m : -(value / pixel2m);
    if (obj.instanceof.type != "slide" && obj.instanceof.type != "rope") {
        obj.ymin = obj.ymax - (value / pixel2m);

        obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
        obj.draw();
    } else if (obj.instanceof.type == "rope") {
        if (obj.instanceof.up) {
            obj.ymin = obj.ymax - (value / pixel2m);

            obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
            obj.draw();
        } else {
            obj.ymax = obj.ymin + (value / pixel2m);

            obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
            obj.draw();
        }
    } else {
        obj.fire("dragend");
    }
    return true;
}

function ropeupdatelength(rope, value) {
    rope.d = value / pixel2m;
    if (rope.up) {
        rope.yend = rope.ystart - (value / pixel2m);
    } else {
        rope.yend = rope.ystart + (value / pixel2m);
    }
    rope.getChildren()[0].points([rope.xstart, rope.ystart, rope.xend, rope.yend]);
    rope.draw();
}

function forceupdatelength(force, value) {
    force.d = value / pixel2m;
    /*if (force.up) {
        force.yend = force.ystart - (value / pixel2m);
    } else {
        force.yend = force.ystart + (value / pixel2m);
    }
    force.getChildren()[0].points(arrowpoint(force.xstart, force.ystart, force.xend, force.yend, force.reverse));
    force.draw();*/
    forcerotate(force, force.angle);
}

function pulleyupdater(pulley, value) {
    pulley.r = value / pixel2m;

    pulley.getChildren()[0].setRadius(pulley.r);
    pulley.draw();
    pulleyupdaterope(pulley);
}

function wheelupdater(wheel, value) {
    wheel.r = value / pixel2m;

    wheel.getChildren()[0].setRadius(wheel.r);
    wheel.draw();
    wheelupdaterope(wheel);
}

function wheelupdaterinner(wheel, value) {
    wheel.rinner = value / pixel2m;

    wheel.getChildren()[1].setRadius(wheel.rinner);
    wheel.draw();
    wheelupdaterope(wheel);
}

function wedgeupdatewidth(wedge, value) {
    var center = (wedge.xstart + wedge.xend) / 2;
    wedge.xstart = center - (value / pixel2m / 2);
    wedge.xend = center + (value / pixel2m / 2);
    wedge.width = value / pixel2m;

    wedge.getChildren()[0].points([wedge.xstart, wedge.ystart, wedge.xend, wedge.ystart, center, stageh - 63]);
    wedge.draw();
    return true;
}

function wedgeupdateheight(wedge, value) {
    wedge.ystart = (stageh - 60) - (value / pixel2m);
    wedge.height = value / pixel2m;

    wedge.getChildren()[0].points([wedge.xstart, wedge.ystart, wedge.xend, wedge.ystart, (wedge.xstart + wedge.xend) / 2, stageh - 63]);
    wedge.draw();
    return true;
}

function screwupdatewidth(screw, value) {
    screw.xmin = screw.center - value / pixel2m / 2;
    screw.xmax = screw.center + value / pixel2m / 2;
    screw.width = value / pixel2m;

    if ((screw.xmax < screw.objcentermax || screw.xmin > screw.objcentermin) && (screw.objcentermax != -1 || screw.objcentermin != -1)) {
        return false;
    } else {
        //screw.getChildren()[0].points([screw.xmin, screw.y, screw.xmin, stageh - 70, screw.xmax, stageh - 70, screw.xmax, screw.y]);
        updatescrew(screw);
        screw.draw();
        return true;
    }
}

function screwupdateheight(screw, value) {
    screw.y = (stageh - 70) - (value / pixel2m);
    screw.height = value / pixel2m;

    /*if ((screw.xmax < screw.objcentermax || screw.xmin > screw.objcentermin) && (screw.objcentermax != -1 || screw.objcentermin != -1)) {
        return false;
    } else {*/
        //screw.getChildren()[0].points([screw.xmin, screw.y, screw.xmin, stageh - 70, screw.xmax, stageh - 70, screw.xmax, screw.y]);
    updatescrew(screw);
    screw.draw();
    return true;
    //}
}

function screwupdatehandd(screw, value) {
    screw.handd = value / pixel2m;

    updatescrew(screw);
    screw.draw();
}

function screwupdateh(screw, value) {
    screw.h = value / pixel2m;

    updatescrew(screw);
    screw.draw();
}

function beamupdateefulcrum(beam, e, value) {
    var d = value / pixel2m;

    e.xstart = e.xstartori = beam.fulcrum + d;
    e.xend = beam.fulcrum + d;
    beamrotate(beam, 0);
    //console.log(obj.points);
}

function beamupdatewfulcrum(beam, obj, value) {
	var d = value / pixel2m;
	
	obj.center = obj.centerori = beam.fulcrum - d;
	obj.xmin = obj.center - obj.width / 2;
	obj.xmax = obj.center + obj.width / 2;
	beamrotate(beam, 0);
	//console.log(obj.points);
}

function binddatainput() {
	$(".datainput").bind("focus",function () {
		inputtemp = $(this).val();
	});
	$(".datainputfloat").bind("change",function () {
		var value = parseFloat($(this).val());
		if (isNaN(value)) {
			$(this).val(inputtemp);
		} else {
		    if ($(this).hasClass("datainputg")) { if (optiontemp.g == value) { return; } if (value >= 0) { optiontemp.g = value; } else { $(this).val(inputtemp); } }
		    if ($(this).hasClass("datainputratio")) { if (optiontemp.ratio == value) { return; } if (value > 0) { optiontemp.ratio = value; } else { $(this).val(inputtemp); } }
		    if ($(this).hasClass("datainputdecimalround")) { if (optiontemp.decimalround == value) { return; } if (value > 0) { optiontemp.decimalround = value; } else { $(this).val(inputtemp); } }

		    if ($(this).hasClass("datainputweight")) if (value < 0) { $(this).val(inputtemp); } else { updateweight(selected[0], value); }
		    if ($(this).hasClass("datainputf")) if (value < 0) { $(this).val(inputtemp); } else { updatef(selected[0], value); }
			if ($(this).hasClass("datainputw")) if (value < 0) { $(this).val(inputtemp); } else { selected[0].w = value; }
			if ($(this).hasClass("datainputu")) if (value >= 0 && value <= 1) { selected[0].u = value; } else { $(this).val(inputtemp); }

			if ($(this).hasClass("datainputweight1")) if (value < 0) { $(this).val(inputtemp); } else { updateweight(objects[1], value); }
			if ($(this).hasClass("datainputf1")) if (value < 0) { $(this).val(inputtemp); } else { updatef(objects[1], value); }
			if ($(this).hasClass("datainputweight2")) if (value < 0) { $(this).val(inputtemp); } else { updateweight(objects[2], value); }
			if ($(this).hasClass("datainputf2")) if (value < 0) { $(this).val(inputtemp); } else { updatef(objects[2], value); }
			if ($(this).hasClass("datainputweight4")) if (value < 0) { $(this).val(inputtemp); } else { updateweight(objects[4], value); }
			if ($(this).hasClass("datainputf5")) if (value < 0) { $(this).val(inputtemp); } else { updatef(objects[5], value); }

			if ($(this).hasClass("datainputbeamwidth")) if (value > 0) { if (!beamupdatewidth(selected[0], value)) { $(this).val(inputtemp); } } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputbeamheight")) if (value > 0) { beamupdateheight(selected[0], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputbeamheight2")) if (value > 0) { beamupdatebaseheight(selected[0], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputdfromfulcrum")) if (selected[0].instanceof.fulcrum + (value / pixel2m) <= selected[0].instanceof.xmax && selected[0].instanceof.fulcrum + (value / pixel2m) >= selected[0].instanceof.xmin) { objupdatedfromfulcrum(selected[0], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputfulcrumpos")) if (value >= 0 && value <= 100) { beamupdatefulcrumpos(selected[0], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputefulcrum")) if (value >= 0) { beamupdateefulcrum(selected[0], objects[2], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputwfulcrum")) if (value >= 0) { beamupdatewfulcrum(selected[0], objects[1], value); } else { $(this).val(inputtemp); }

			if ($(this).hasClass("datainputslidedfromend")) if (value > 0) { objslideupdatedfromend(selected[0], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputslideheight")) if (value > 0) { if (!slideupdateheight(selected[0], value)) { $(this).val(inputtemp) }; } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputslidewidth")) if (value > 0) { if (!slideupdatewidth(selected[0], value)) { $(this).val(inputtemp) }; } else { $(this).val(inputtemp); }

			if ($(this).hasClass("datainputobjwidth")) if (value > 0) { if (!objupdatewidth(selected[0], value)) { $(this).val(inputtemp); } } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputobjheight")) if (value > 0) { if (!objupdateheight(selected[0], value)) { $(this).val(inputtemp); } } else { $(this).val(inputtemp); }

			if ($(this).hasClass("datainputropelength")) if (value > 0 && !selected[0].locked) { ropeupdatelength(selected[0], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputforcelength")) if (value > 0) { forceupdatelength(selected[0], value); } else { $(this).val(inputtemp); }

			if ($(this).hasClass("datainputpulleyr")) if (value > 0) { pulleyupdater(selected[0], value); } else { $(this).val(inputtemp); }

			if ($(this).hasClass("datainputwheelr")) if (value > 0 && value / pixel2m > selected[0].rinner) { wheelupdater(selected[0], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputwheelrinner")) if (value > 0 && value / pixel2m < selected[0].r) { wheelupdaterinner(selected[0], value); } else { $(this).val(inputtemp); }

			if ($(this).hasClass("datainputwedgewidth")) if (value > 0) { if (!wedgeupdatewidth(selected[0], value)) { $(this).val(inputtemp); } } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputwedgeheight")) if (value > 0) { if (!wedgeupdateheight(selected[0], value)) { $(this).val(inputtemp); } } else { $(this).val(inputtemp); }

			if ($(this).hasClass("datainputscrewwidth")) if (value > 0) { if (!screwupdatewidth(selected[0], value)) { $(this).val(inputtemp); } } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputscrewheight")) if (value > 0) { if (!screwupdateheight(selected[0], value)) { $(this).val(inputtemp); } } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputscrewhandd")) if (value > 0) { screwupdatehandd(selected[0], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputscrewh")) if (value > 0) { screwupdateh(selected[0], value); } else { $(this).val(inputtemp); }
			if ($(this).hasClass("datainputscrewe")) if (value > 0) { selected[0].e = value } else { $(this).val(inputtemp); }

			/*if (selected[0]) {
			    var currentselected = selected[0];
			    clearselection();
			    toggleselection(currentselected);
			}*/

			updatestatus();

		    /*if (!$(this).hasClass("datainputnoround")) {
				$(this).val(value.toFixed(decimalround));
			}*/
			inputtemp = $(this).val();
		}
	});
}

function updatestatus() {
    try {
        switch (currenttool) {
            case 1:
                var obj = objects[0];
                selected[0] = obj;
                var slided = Math.linear.getPointDistance(obj.xstart, obj.ystart, obj.xend, stageh - 60, true);
                var slideh = slided * Math.sin(obj.angle * Math.PI / 180);
                $("#statusbar").html(
                    '<b>มุม: </b>' + caldecimalround(obj.angle) + ' องศา<br />' +
                    //'<b>สัมประสิทธิ์แรงเสียดทาน: </b><input type="text" class="datainput datainputfloat datainputu" value="'+obj.u+'"><br />'+
                    '<b>ความได้เปรียบเชิงกล: </b>' + caldecimalround(slided / slideh) + '<br />'+
					'<b>แรงพยายาม: </b><input type="text" class="datainput datainputfloat datainputf2" value="' + objects[2].force + '"> นิวตัน<br />'+
                    '<b>น้ำหนักของวัตถุ (แรงต้าน): </b><input type="text" class="datainput datainputfloat datainputweight1" value="' + objects[1].weight + '"> กรัม<br />'             
				);
                $("#rulerbar").html(
                    '<b>ความยาวของฐาน: </b><input type="text" class="datainput datainputfloat datainputslidewidth" value="' + caldecimalround(obj.xend * pixel2m) + '"> เมตร<br />' +
                    '<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputslideheight" value="' + caldecimalround(slideh * pixel2m) + '"> เมตร<br />' //+
                    //'<b>ความสูงของฐาน: </b><input type="text" class="datainput datainputfloat datainputbeamheight2" value="' + ((obj.getChildren()[0].getRadius() + 1 / 2 * obj.getChildren()[0].getRadius()) * pixel2m) + '"> เมตร<br />'
                );
                break;
            case 2:
                var obj = objects[0];
                selected[0] = obj;
                var moment = calmoment(obj);
                $("#statusbar").html(
					//'<b><u>คาน [ID: ' + obj.id + ']</u></b><br />' +
					//'<b>น้ำหนัก: </b><input type="text" class="datainput datainputfloat datainputweight" value="' + obj.weight + '"> กรัม<br />' +
					'<b>โมเมนต์ตาม: </b>' + caldecimalround(moment.momentr) + ' นิวตัน<span id="middot">⋅</span>เมตร<br />' +
					'<b>โมเมนต์ทวน: </b>' + caldecimalround(moment.momentl) + ' นิวตัน<span id="middot">⋅</span>เมตร<br />' +
					//'<b>สมดุล: </b>' + (moment.momentr.toFixed(10) == moment.momentl.toFixed(10) ? 'สมดุล' : (moment.momentr.toFixed(10) > moment.momentl.toFixed(10) ? 'ไม่สมดุล (หมุนตามเข็มนาฬิกา)' : 'ไม่สมดุล (หมุนทวนเข็มนาฬิกา)')) + '<br />' +
                    //'<b>ตำแหน่งของจุดหมุน: </b><input type="text" class="datainput datainputfloat datainputfulcrumpos" value="' + caldecimalround((obj.fulcrum - obj.xmin) / (obj.xmax - obj.xmin) * 100) + '">%<br />'
					'<b>ระยะทางจากแรงพยายามถึงคาน: </b><input type="text" class="datainput datainputfloat datainputefulcrum" value="' + caldecimalround((objects[2].xend - obj.fulcrum) * pixel2m) + '"> เมตร<br />'+
					'<b>ระยะทางจากแรงต้านถึงคาน: </b><input type="text" class="datainput datainputfloat datainputwfulcrum" value="' + caldecimalround((obj.fulcrum - objects[1].center) * pixel2m) + '"> เมตร<br />'
				);
                $("#rulerbar").html(
                    '<b>ความกว้าง: </b><input type="text" class="datainput datainputfloat datainputbeamwidth" value="' + caldecimalround((obj.xmax - obj.xmin) * pixel2m) + '"> เมตร<br />' +
                    //'<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputbeamheight" value="' + caldecimalround((obj.ymax - obj.ymin) * pixel2m) + '"> เมตร<br />' +
                    '<b>ความสูงของฐาน: </b><input type="text" class="datainput datainputfloat datainputbeamheight2" value="' + caldecimalround((obj.getChildren()[0].getRadius() + 1 / 2 * obj.getChildren()[0].getRadius()) * pixel2m) + '"> เมตร<br />'+
					'<b>แรงพยายาม: </b><input type="text" class="datainput datainputfloat datainputf2" value="' + objects[2].force + '"> นิวตัน<br />'+
                    '<b>น้ำหนักของวัตถุ (แรงต้าน): </b><input type="text" class="datainput datainputfloat datainputweight1" value="' + objects[1].weight + '"> กรัม<br />'             
                );
                break;
            case 3:
                var obj = objects[0];
                selected[0] = obj;
                $("#statusbar").html(
					//'<b><u>รอก [ID: ' + obj.id + ']</u></b><br />' +
					'<b>ชนิดของรอก: </b><select class="datainputpulleytype" style="width:325px;">' +
						'<option value="0">รอกเดี่ยวตายตัวยึดกับเพดาน</option>' +
						'<!--<option value="1">รอกเดี่ยวตายตัวยึดกับพื้น</option>-->' +
						'<option value="2">รอกเดี่ยวเคลื่อนที่เชือกด้านซ้ายยึดกับเพดาน</option>' +
						'<option value="3">รอกเดี่ยวเคลื่อนที่เชือกด้านขวายึดกับเพดาน</option>' +
						'<!--<option value="4">รอกเดี่ยวเคลื่อนที่เชือกด้านซ้ายยึดกับพื้น</option>-->' +
						'<!--<option value="5">รอกเดี่ยวเคลื่อนที่เชือกด้านขวายึดกับพื้น</option>-->' +
					'</select><br />'+
					//'<b>น้ำหนัก: </b><input type="text" class="datainput datainputfloat datainputweight datainputweight" value="'+obj.weight+'"> กรัม<br />'
				    '<b>แรงพยายาม: </b><input type="text" class="datainput datainputfloat datainputf5" value="' + objects[5].force + '"> นิวตัน<br />'+
                    '<b>น้ำหนักของวัตถุ (แรงต้าน): </b><input type="text" class="datainput datainputfloat datainputweight4" value="' + objects[4].weight + '"> กรัม<br />'
                );
                $("#rulerbar").html(
                    '<b>รัศมี: </b><input type="text" class="datainput datainputfloat datainputpulleyr" value="' + caldecimalround(obj.r * pixel2m) + '"> เมตร<br />'//+
                    /*'<b>ความยาวของเชือกด้านซ้าย: </b><input type="text" class="datainput datainputfloat datainputropelength1" value="' + caldecimalround(objects[1].d * pixel2m) + '"> เมตร<br />'+
                    '<b>ความยาวของเชือกตรงกลาง: </b><input type="text" class="datainput datainputfloat datainputropelength3" value="' + caldecimalround(objects[3].d * pixel2m) + '"> เมตร<br />'+
                    '<b>ความยาวของเชือกด้านขวา: </b><input type="text" class="datainput datainputfloat datainputropelength2" value="' + caldecimalround(objects[2].d * pixel2m) + '"> เมตร<br />'*/
                );
                $(".datainputpulleytype").val(obj.pulleytype);
                $(".datainputpulleytype").change(function () {
                    setpulleytype(obj, parseInt($(this).val()));
                    console.log("aaa");
                });
                break;
            case 4:
                var obj = objects[0];
                selected[0] = obj;
                $("#statusbar").html(
					//'<b><u>ลิ่ม [ID: ' + obj.id + ']</u></b><br />' +
					'<b>น้ำหนัก: </b><input type="text" class="datainput datainputfloat datainputweight" value="' + obj.weight + '"> กรัม<br />'+
					'<b>แรงพยายาม: </b><input type="text" class="datainput datainputfloat datainputf1" value="' + objects[1].force + '"> นิวตัน<br />'+
					'<b>แรงต้าน: </b><input type="text" class="datainput datainputfloat datainputw" value="'+obj.w+'"> นิวตัน<br />'
				);
                $("#rulerbar").html(
                    '<b>ความกว้าง: </b><input type="text" class="datainput datainputfloat datainputwedgewidth" value="' + caldecimalround(obj.width * pixel2m) + '"> เมตร<br />' +
                    '<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputwedgeheight" value="' + caldecimalround(obj.height * pixel2m) + '"> เมตร<br />'
                );
                break;
            case 5:
                var obj = objects[0];
                selected[0] = obj;
                $("#statusbar").html(
					//'<b><u>ล้อและเพลา [ID: ' + obj.id + ']</u></b><br />' +
                    '<b>ความได้เปรียบเชิงกล: </b>' + caldecimalround(obj.r / obj.rinner)+'<br />'+
                    '<b>น้ำหนักของวัตถุ (แรงต้าน): </b><input type="text" class="datainput datainputfloat datainputweight1" value="' + objects[1].weight + '"> กรัม<br />' +
                    '<b>แรงพยายาม: </b><input type="text" class="datainput datainputfloat datainputf2" value="' + objects[2].force + '"> นิวตัน<br />'

				);
                $("#rulerbar").html(
                    '<b>รัศมีของล้อ: </b><input type="text" class="datainput datainputfloat datainputwheelr" value="' + caldecimalround(obj.r * pixel2m) + '"> เมตร<br />' +
                    '<b>รัศมีของเพลา: </b><input type="text" class="datainput datainputfloat datainputwheelrinner" value="' + caldecimalround(obj.rinner * pixel2m) + '"> เมตร<br />'
                );
                break;
            case 6:
                var obj = objects[0];
                selected[0] = obj;
                $("#statusbar").html(
                    //'<b><u>สกรู [ID: ' + obj.id + ']</u></b><br />' +
                    '<b>ระยะทาง 1 ช่วงเกลียว: </b><input type="text" class="datainput datainputfloat datainputscrewh" value="' + caldecimalround(obj.h * pixel2m) + '"> เมตร<br />' +
                    '<b>แรงพยายาม: </b><input type="text" class="datainput datainputfloat datainputscrewe" value="' + obj.e + '"> นิวตัน<br />' +
                    '<b>ความได้เปรียบเชิงกล: </b>' + caldecimalround((2 * Math.PI * obj.handd) / obj.h)+'<br />'+
                    '<b>น้ำหนักของวัตถุ (แรงต้าน): </b><input type="text" class="datainput datainputfloat datainputweight1" value="' + objects[1].weight + '"> กรัม<br />'

                );
                $("#rulerbar").html(
                    '<b>ความกว้าง: </b><input type="text" class="datainput datainputfloat datainputscrewwidth" value="' + caldecimalround(obj.width * pixel2m) + '"> เมตร<br />' +
                    '<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputscrewheight" value="' + caldecimalround(obj.height * pixel2m) + '"> เมตร<br />' +
                    '<b>ความยาวของด้ามสกรู: </b><input type="text" class="datainput datainputfloat datainputscrewhandd" value="' + caldecimalround(obj.handd * pixel2m) + '"> เมตร<br />'
                );
                break;
            default:
                $("#statusbar").html('<b>กรุณาเลือกชนิดของเครื่องกลเพื่อทำการจำลอง</b>');
                $("#rulerbar").html('');
                break;
        }
    } catch (e) { }
    binddatainput();
}

/*function updatestatus () {
	//var l = 0;
	var selected = getselectedobjects();
	if (selected.length == 1) {
		var obj = selected[0];
		switch (obj.type) {
		    case "beam":
		        var moment = calmoment(obj);
				$("#statusbar").html(
					'<b><u>คาน [ID: '+obj.id+']</u></b><br />'+
					'<b>น้ำหนัก: </b><input type="text" class="datainput datainputfloat datainputweight" value="'+obj.weight+'"> กรัม<br />'+
					'<b>โมเมนต์ตาม: </b>'+caldecimalround(moment.momentr)+' นิวตัน<span id="middot">⋅</span>เมตร<br />'+
					'<b>โมเมนต์ทวน: </b>'+caldecimalround(moment.momentl)+' นิวตัน<span id="middot">⋅</span>เมตร<br />'+
					'<b>สมดุล: </b>'+(moment.momentr.toFixed(10)==moment.momentl.toFixed(10)?'สมดุล':(moment.momentr.toFixed(10)>moment.momentl.toFixed(10)?'ไม่สมดุล (หมุนตามเข็มนาฬิกา)':'ไม่สมดุล (หมุนทวนเข็มนาฬิกา)'))+'<br />'+
                    '<b>ตำแหน่งของจุดหมุน: </b><input type="text" class="datainput datainputfloat datainputfulcrumpos" value="' + caldecimalround((obj.fulcrum - obj.xmin) / (obj.xmax - obj.xmin) * 100) + '">%<br />'
				);
				$("#rulerbar").html(
                    '<b>ความกว้าง: </b><input type="text" class="datainput datainputfloat datainputbeamwidth" value="' + caldecimalround((obj.xmax - obj.xmin) * pixel2m) + '"> เมตร<br />' +
                    '<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputbeamheight" value="' + caldecimalround((obj.ymax - obj.ymin) * pixel2m) + '"> เมตร<br />' +
                    '<b>ความสูงของฐาน: </b><input type="text" class="datainput datainputfloat datainputbeamheight2" value="' + caldecimalround((obj.getChildren()[0].getRadius() + 1 / 2 * obj.getChildren()[0].getRadius()) * pixel2m) + '"> เมตร<br />'
                );
				break;
			case "object":
				$("#statusbar").html(
					'<b><u>วัตถุ [ID: '+obj.id+']</u></b><br />'+
					'<b>เป็นส่วนหนึ่งของ</b> '+engtothaitype(obj.instanceof.type)+' [ID: '+obj.instanceof.id+']<br />'+
					'<b>น้ำหนัก: </b><input type="text" class="datainput datainputfloat datainputweight" value="'+obj.weight+'"> กรัม<br />'
				);
				if (obj.instanceof.type != "slide") {
				    $("#rulerbar").html(
                        '<b>ความกว้าง: </b><input type="text" class="datainput datainputfloat datainputobjwidth" value="' + caldecimalround((obj.xmax - obj.xmin) * pixel2m) + '"> เมตร<br />' +
                        '<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputobjheight" value="' + caldecimalround((obj.ymax - obj.ymin) * pixel2m) + '"> เมตร<br />'
                    );
				} else {
				    $("#rulerbar").html(
                        '<b>ความกว้าง: </b><input type="text" class="datainput datainputfloat datainputobjwidth" value="' + caldecimalround(obj.width * pixel2m) + '"> เมตร<br />' +
                        '<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputobjheight" value="' + caldecimalround(Math.abs(obj.height * pixel2m)) + '"> เมตร<br />'
                    );
				}
				switch (obj.instanceof.type) {
					case "slide": 
						$("#statusbar").append(
							'<b>ระยะทางจากพื้น: </b><input type="text" class="datainput datainputfloat datainputslidedfromend" value="' + caldecimalround(obj.dfromend * pixel2m) + '"> เมตร'
						);
						break;
				    case "beam":
				        $("#statusbar").append(
							'<b>ระยะทางจากจุดหมุน: </b><input type="text" class="datainput datainputfloat datainputdfromfulcrum" value="' + caldecimalround((obj.center - obj.instanceof.fulcrum) * pixel2m) + '"> เมตร'
						);
				}
				break;
			case "rope":
				$("#statusbar").html(
					'<b><u>เชือก [ID: '+obj.id+']</u></b><br />'+
					'<b>เป็นส่วนหนึ่งของ</b> '+engtothaitype(obj.instanceof.type)+' [ID: '+obj.instanceof.id+']<br />'//+
					//'<b>น้ำหนัก: </b><input type="text" class="datainput datainputfloat datainputweight" value="'+obj.weight+'"> กรัม<br />'
				);
				$("#rulerbar").html(
                    '<b>ความยาว: </b><input type="text" class="datainput datainputfloat datainputropelength" value="' + caldecimalround(obj.d * pixel2m) + '"> เมตร<br />'
                );
				break;
			case "slide":
				var slided = Math.linear.getPointDistance(obj.xstart,obj.ystart,obj.xend,stageh-60,true);
				var slideh = slided*Math.sin(obj.angle*Math.PI/180);
				//if ((Math.sin(obj.angle*Math.PI/180)-obj.u*Math.cos(obj.angle*Math.PI/180) > 0)) {
					//console.log(obj.u*Math.cos(obj.angle*Math.PI/180)*slided);
					slided += obj.u*Math.cos(obj.angle*Math.PI/180)*slided;
					
				//}

				$("#statusbar").html(
					'<b><u>พื้นเอียง [ID: '+obj.id+']</u></b><br />'+
					'<b>ความชัน: </b>'+caldecimalround(Math.abs(obj.equation.equation.a))+' ('+caldecimalround(obj.angle)+' องศา)<br />'+
					//'<b>สัมประสิทธิ์แรงเสียดทาน: </b><input type="text" class="datainput datainputfloat datainputu" value="'+obj.u+'"><br />'+
					'<b>ความได้เปรียบเชิงกล: </b>' + caldecimalround(slided / slideh) + '<br />'
				);
				$("#rulerbar").html(
                    '<b>ความยาวของฐาน: </b><input type="text" class="datainput datainputfloat datainputslidewidth" value="' + caldecimalround((obj.xend - obj.xstart) * pixel2m) + '"> เมตร<br />' +
                    '<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputslideheight" value="' + caldecimalround(slideh * pixel2m) + '"> เมตร<br />' //+
                    //'<b>ความสูงของฐาน: </b><input type="text" class="datainput datainputfloat datainputbeamheight2" value="' + ((obj.getChildren()[0].getRadius() + 1 / 2 * obj.getChildren()[0].getRadius()) * pixel2m) + '"> เมตร<br />'
                );
				break;
			case "wedge":
				$("#statusbar").html(
					'<b><u>ลิ่ม [ID: '+obj.id+']</u></b><br />'+
					'<b>น้ำหนัก: </b><input type="text" class="datainput datainputfloat datainputweight" value="'+obj.weight+'"> กรัม<br />'//+
					//'<b>แรงต้าน: </b><input type="text" class="datainput datainputfloat datainputw" value="'+obj.w+'"> นิวตัน<br />'
				);
				$("#rulerbar").html(
                    '<b>ความกว้าง: </b><input type="text" class="datainput datainputfloat datainputwedgewidth" value="' + caldecimalround(obj.width * pixel2m) + '"> เมตร<br />' +
                    '<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputwedgeheight" value="' + caldecimalround(obj.height * pixel2m) + '"> เมตร<br />'
                );
				break;
			case "wheel":
				$("#statusbar").html(
					'<b><u>ล้อและเพลา [ID: '+obj.id+']</u></b><br />'+
                    '<b>ความได้เปรียบเชิงกล: </b>' + caldecimalround(obj.r / obj.rinner)
				);
				$("#rulerbar").html(
                    '<b>รัศมีของล้อ: </b><input type="text" class="datainput datainputfloat datainputwheelr" value="' + caldecimalround(obj.r * pixel2m) + '"> เมตร<br />' +
                    '<b>รัศมีของเพลา: </b><input type="text" class="datainput datainputfloat datainputwheelrinner" value="' + caldecimalround(obj.rinner * pixel2m) + '"> เมตร<br />'
                );
				break;
			case "pulley":
				$("#statusbar").html(
					'<b><u>รอก [ID: '+obj.id+']</u></b><br />'+
					'<b>ชนิดของรอก: </b><select class="datainputpulleytype" style="width:325px;">'+
						'<option value="0">รอกเดี่ยวตายตัวยึดกับเพดาน</option>'+
						'<!--<option value="1">รอกเดี่ยวตายตัวยึดกับพื้น</option>-->'+
						'<option value="2">รอกเดี่ยวเคลื่อนที่เชือกด้านซ้ายยึดกับเพดาน</option>'+
						'<option value="3">รอกเดี่ยวเคลื่อนที่เชือกด้านขวายึดกับเพดาน</option>'+
						'<!--<option value="4">รอกเดี่ยวเคลื่อนที่เชือกด้านซ้ายยึดกับพื้น</option>-->'+
						'<!--<option value="5">รอกเดี่ยวเคลื่อนที่เชือกด้านขวายึดกับพื้น</option>-->'+
					'</select><br />'//+
					//'<b>น้ำหนัก: </b><input type="text" class="datainput datainputfloat datainputweight datainputweight" value="'+obj.weight+'"> กรัม<br />'
				);
				$("#rulerbar").html(
                    '<b>รัศมี: </b><input type="text" class="datainput datainputfloat datainputpulleyr" value="' + caldecimalround(obj.r * pixel2m) + '"> เมตร<br />'
                );
				$(".datainputpulleytype").val(obj.pulleytype);
				$(".datainputpulleytype").change(function () {
					setpulleytype(obj,parseInt($(this).val()));
					console.log("aaa");
				});
				break;
		    case "screw":
		        $("#statusbar").html(
					'<b><u>สกรู [ID: ' + obj.id + ']</u></b><br />' +
                    '<b>ระยะทาง 1 ช่วงเกลียว: </b><input type="text" class="datainput datainputfloat datainputscrewh" value="' + caldecimalround(obj.h * pixel2m) + '"> เมตร<br />' +
                    '<b>แรงพยายาม: </b><input type="text" class="datainput datainputfloat datainputscrewe" value="' + obj.e + '"> นิวตัน<br />' +
                    '<b>ความได้เปรียบเชิงกล: </b>' + caldecimalround((2 * Math.PI * obj.handd) / obj.h)
				);
		        $("#rulerbar").html(
                    '<b>ความกว้าง: </b><input type="text" class="datainput datainputfloat datainputscrewwidth" value="' + caldecimalround(obj.width * pixel2m) + '"> เมตร<br />' +
                    '<b>ความสูง: </b><input type="text" class="datainput datainputfloat datainputscrewheight" value="' + caldecimalround(obj.height * pixel2m) + '"> เมตร<br />' +
                    '<b>ความยาวของด้ามสกรู: </b><input type="text" class="datainput datainputfloat datainputscrewhandd" value="' + caldecimalround(obj.handd * pixel2m) + '"> เมตร<br />'
                );
		        break;
			case "force":
				$("#statusbar").html(
					'<b><u>แรง [ID: '+obj.id+']</u></b><br />'+
					'<b>เป็นส่วนหนึ่งของ</b> '+engtothaitype(obj.instanceof.type)+' [ID: '+obj.instanceof.id+']<br />'+
					'<b>แรง: </b><input type="text" class="datainput datainputfloat datainputf" value="'+obj.force+'"> นิวตัน<br />'+
					((obj.reverseable)?('<input class="datainputreverse" type="checkbox"'+((obj.reverse)?"checked":"")+'> กลับทิศทางแรง'):'')
				);
				$("#rulerbar").html(
                    '<b>ความยาว: </b><input type="text" class="datainput datainputfloat datainputforcelength" value="' + caldecimalround(obj.d * pixel2m) + '"> เมตร<br />'
                );
				$(".datainputreverse").change(function () {
					obj.reverse = $(this).is(":checked");
					obj.getChildren()[0].points(arrowpoint(obj.xstart,obj.ystart,obj.xend,obj.yend,obj.reverse));
					obj.draw();
					
					var root = obj.instanceof;
					switch (root.type) {
						case "beam": 
						var moment = calmoment(root);
						root.momentr = moment.momentr;
						root.momentl = moment.momentl;
						break;
					}
				});
				break;
			default:
				$("#statusbar").html(
					'<span style="color:red;"><b><u>!!! ไม่มีข้อมูล กรุณาติดต่อผู้สร้างโปรแกรม !!!</u></b></span>'
				);
				break;
		}
		binddatainput();
	} else if (selected.length == 0) {
	    $("#statusbar").html('<b>เลือกเครื่องกล,วัตถุ,แรง,เชือกเพื่อดูหรือปรับค่าต่างๆ</b>');
	    $("#rulerbar").html('');
	}
}*/

function updateselection (obj) {
	if (selectionlayer.selects[obj.id] != null) {
		var bounds = getobjectbounds(obj,true);
		selectionlayer.selects[obj.id].points([bounds.xmin-3,bounds.ymin-3,bounds.xmax+3,bounds.ymin-3,bounds.xmax+3,bounds.ymax+3,bounds.xmin-3,bounds.ymax+3]);
		selectionlayer.draw();
	}
}

function addselection (obj) {
	obj.selected = true;
	if (selected.indexOf(obj) == -1) {
		selected.push(obj);
	}
	obj.fire("select");
	//if (!obj.selected) {
		/*var bounds = getobjectbounds(obj,true);
		var select = new Kinetic.Line({
			points: [bounds.xmin-3,bounds.ymin-3,bounds.xmax+3,bounds.ymin-3,bounds.xmax+3,bounds.ymax+3,bounds.xmin-3,bounds.ymax+3],
			stroke: '#808000',
			strokeWidth: 2,
			closed: true,
			dash: [10, 5]
		});
		select.id = obj.id;
		selectionlayer.add(select);
		selectionlayer.draw();
		selectionlayer.setZIndex(obj.getZIndex());
		obj.moveUp();
		selectionlayer.selects[obj.id] = select;*/
			
		
		
		//add anchor
		objcreateanchor(obj);
		//console.log(selected);
		updatestatus();
	//} else {
		//updateselection(obj);
	//}
}

function removeselection (obj) {
	obj.selected = false;
	obj.fire("unselect");
	selected.splice(selected.indexOf(obj),1);
	/*if (selectionlayer.selects[obj.id] != null) {
		selectionlayer.selects[obj.id].remove();
		selectionlayer.draw();
		selectionlayer.selects[obj.id] = null;
		objremoveanchor(obj);
	}*/
}

function toggleselection (obj) {
	if (!obj.selected) {
		addselection(obj);
	} else {
		removeselection(obj);
	}
	updatestatus();
}

function selectone (obj,force) {
	//console.log("aaa");
	if (!obj.selected || selected.length > 1) {
		clearselection();
	}
	if (!force) {
		toggleselection(obj);
	} else {
		addselection(obj);
	}
}

function selectiondrag (obj) {
	if (currenttool == -1) {
		mousedrageffect = false;
		if (!obj.ondragblocker) {
			selectone(obj,true);
			obj.ondrag = true;
			updateallanchor();
		} else {
			obj.ondragblocker = false;
		}
	}
}

//mouseup and dragend
function selectiondragend (obj) {}
//selectiondragend
$(document).mouseup(function (e) {
	if (ondragobj) {
		var selected = ondragobj.selected;
		clearselection();
		if (ondragobj.ondrag || !selected) {
			addselection(ondragobj);
			
			//Fix anchor bug
			if (ondragobj.type == "object") {
				addselection(ondragobj.instanceof);
				clearanchor();
				//objremoveanchor(ondragobj.instanceof);
				clearselection();
				addselection(ondragobj)
			}
			if (ondragobj.type == "beam") {
				$.each(ondragobj.objects,function(index,obj) {
					addselection(obj);
					objremoveanchor(obj);
				});
				clearselection();
				addselection(ondragobj)
			}
		}
		updatestatus();
		
		mousedrageffect = true;
		ondragobj.ondrag = false;
		ondragobj.ondragblocker = true;
		
		ondragobj = null;
	}
});

function clearselection () {
	/*selectionlayer.removeChildren();
	selectionlayer.draw();
	selectionlayer.selects = [];*/
	clearanchor();
	
	$.each(objects,function (index,value) {
		removeselection(value);
	})
}

function getselectedobjects () {
	var result = [];
	$.each(selected,function (index,value) {
		if (value != null) {
			result.push(objects[value.id]);
		}
	});
	//console.log(result);
	return result;
}

function floorslide (layer,x,y) {
	layer.remove();
	layer = new Kinetic.Layer();

}

function getobjectbounds (obj,border) {
	var xmin = -1;
	var xmax = -1;
	var ymin = -1;
	var ymax = -1;
	var bordersize = 0;
	switch (obj.type) {
		case "beam":
			if (border) {
				bordersize = 2;
			}
			var xmino = obj.getChildren()[1].getPoints()[0];
			var xmaxo = obj.getChildren()[1].getPoints()[4];
			var ymino = obj.getChildren()[1].getPoints()[1];
			xmin = xmino+obj.getChildren()[1].getAbsolutePosition().x;
			ymin = ymino+obj.getChildren()[1].getAbsolutePosition().y;
			xmax = xmin+(xmaxo-xmino);
			ymax = stageh-60+bordersize;
			
			//base > object
			var basel = Math.sqrt(Math.pow(obj.getChildren()[0].getRadius(),2)-Math.pow((stageh-60-obj.getChildren()[1].getPoints()[3])/3,2));
			var baseminx = obj.fulcrum-basel;
			var basemaxx = obj.fulcrum+basel;
			if (baseminx<xmin) {
				xmin = baseminx;
			}
			if (basemaxx>xmax) {
				xmax = basemaxx;
			}
			break;
		case "object":
			if (border) {
				bordersize = 2;
			}
			var xmino = obj.getChildren()[0].getPoints()[0]-bordersize;
			var xmaxo = obj.getChildren()[0].getPoints()[4]+bordersize;
			var ymino = obj.getChildren()[0].getPoints()[1]-bordersize;
			var ymaxo = obj.getChildren()[0].getPoints()[3]+bordersize;
			xmin = xmino+obj.getChildren()[0].getAbsolutePosition().x;
			ymin = ymino+obj.getChildren()[0].getAbsolutePosition().y;
			xmax = xmin+(xmaxo-xmino);
			ymax = ymin+(ymaxo-ymino);
			break;
	}
	return {xmin:xmin,xmax:xmax,ymin:ymin,ymax:ymax};
}

function shapeminy (shape) {
	var points = shape.points();
	var currentmin = 999999999;
	for (i = 1;i<points.length;i=i+2) {
		if (points[i] < currentmin) {
			currentmin = points[i];
		}
	}
	return currentmin;
}

function shapemaxy (shape) {
	var points = shape.points();
	var currentmax = -1;
	for (i = 1;i<points.length;i=i+2) {
		if (points[i] > currentmax) {
			currentmax = points[i];
		}
	}
	return currentmax;
}

function shapeminx (shape) {
	var points = shape.points();
	var currentmin = 999999999;
	for (i = 0;i<points.length;i=i+2) {
		if (points[i] < currentmin) {
			currentmin = points[i];
		}
	}
	return currentmin;
}

function shapemaxx (shape) {
	var points = shape.points();
	var currentmax = -1;
	for (i = 0;i<points.length;i=i+2) {
		if (points[i] > currentmax) {
			currentmin = points[i];
		}
	}
	return currentmin;
}

function beamrotate (layer,angle) {
	//l + r -
	//layer.maxy = fulcrumy
	var beam = layer.getChildren()[1];
	var dright = layer.xmax-layer.fulcrum;
	var dleft = layer.fulcrum-layer.xmin;
	var maxxd = layer.fulcrum+dright*Math.cos(angle*Math.PI/180);
	var minxd = layer.fulcrum-dleft*Math.cos(angle*Math.PI/180);
	var maxyr = layer.ymax-dright*Math.sin(angle*Math.PI/180);
	var maxyl = layer.ymax+dleft*Math.sin(angle*Math.PI/180);
	//var minyr = layer.ymin-dright*Math.sin(angle*Math.PI/180);
	//var minyl = layer.ymin+dleft*Math.sin(angle*Math.PI/180);
	var h = layer.ymax-layer.ymin;
	var minyl = maxyl-h*Math.cos(angle*Math.PI/180);
	var minxu = minxd-h*Math.sin(angle*Math.PI/180);
	var minyr = maxyr-h*Math.cos(angle*Math.PI/180);
	var maxxu = maxxd-h*Math.sin(angle*Math.PI/180);
	
	layer.angle = angle;
	
	if (Math.max(Math.max(maxyl, maxyr), Math.max(minyl, minyr)) < stageh - 57 && Math.min(Math.min(maxyl, maxyr), Math.min(minyl, minyr)) > 40) {

	//beam.points([minxd,maxyl,maxxd,maxyr,maxxu,minyr,minxu,minyl]);
	beam.points([minxu,minyl,minxd,maxyl,maxxd,maxyr,maxxu,minyr]);
	
	//rotate obj
	$.each(layer.objects,function (index,obj) {
		if (obj.centerori > layer.fulcrum) {
			var dfromfulcrum = obj.centerori-layer.fulcrum;
			var centerx = layer.fulcrum+dfromfulcrum*Math.cos(angle*Math.PI/180);
			var centery = layer.ymax-dfromfulcrum*Math.sin(angle*Math.PI/180);
		} else if (obj.centerori == layer.fulcrum) {
			var centerx = layer.fulcrum;
			var centery = layer.ymax;
		} else {
			var dfromfulcrum = layer.fulcrum-obj.centerori;
			var centerx = layer.fulcrum-dfromfulcrum*Math.cos(angle*Math.PI/180);
			var centery = layer.ymax+dfromfulcrum*Math.sin(angle*Math.PI/180);
		}
		var objhalfw = (obj.xmax-obj.xmin)/2;
		var objmaxxd = centerx+objhalfw*Math.cos(angle*Math.PI/180);
		var objmaxyr = centery-objhalfw*Math.sin(angle*Math.PI/180);
		var objminxd = centerx-objhalfw*Math.cos(angle*Math.PI/180);
		var objmaxyl = centery+objhalfw*Math.sin(angle*Math.PI/180);
		var objh = obj.ymax-obj.ymin;
		var objminxu = objminxd-objh*Math.sin(angle*Math.PI/180);
		var objminyl = objmaxyl-objh*Math.cos(angle*Math.PI/180);
		var objmaxxu = objmaxxd-objh*Math.sin(angle*Math.PI/180);
		var objminyr = objmaxyr-objh*Math.cos(angle*Math.PI/180);
		
		var objxplus = h*Math.sin(angle*Math.PI/180);
		var objyplus = (h+2)*Math.cos(angle*Math.PI/180);

		//obj.getChildren()[0].points([objmaxxd-objxplus,objmaxyr-objyplus,objminxd-objxplus,objmaxyl-objyplus,objminxu-objxplus,objminyl-objyplus,objmaxxu-objxplus,objminyr-objyplus]);
		obj.getChildren()[0].points([objminxu-objxplus,objminyl-objyplus,objminxd-objxplus,objmaxyl-objyplus,objmaxxd-objxplus,objmaxyr-objyplus,objmaxxu-objxplus,objminyr-objyplus]);
		obj.draw();
		
		obj.center = centerx;
	});
	
	//rotate force
	$.each(layer.forces,function (index,f) {
		if (f.xstartori > layer.fulcrum) {
			var dfromfulcrum = f.xstartori-layer.fulcrum;
			var centerx = layer.fulcrum+dfromfulcrum*Math.cos(angle*Math.PI/180);
			var centery = layer.ymax-dfromfulcrum*Math.sin(angle*Math.PI/180);
		} else if (f.xstartori == layer.fulcrum) {
			var centerx = layer.fulcrum;
			var centery = layer.ymax;
		} else {
			var dfromfulcrum = layer.fulcrum-f.xstartori;
			var centerx = layer.fulcrum-dfromfulcrum*Math.cos(angle*Math.PI/180);
			var centery = layer.ymax+dfromfulcrum*Math.sin(angle*Math.PI/180);
		}
		
		var xplus = h*Math.sin(angle*Math.PI/180);
		var yplus = (h+2)*Math.cos(angle*Math.PI/180);
		
		if (f.up) {
			f.xstart = centerx-xplus;
			f.ystart = centery-yplus;
		} else {
			f.xstart = centerx;
			f.ystart = centery;
		}
		
		//console.log(f.xstart);
		
		f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart,f.xend,f.yend,f.reverse));
		forcerotate(f,f.angle-angle);
		
		f.draw();
	});
	
	layer.draw();
	return true;
	} else { return false; }
}

function createanchor (layer,x,y,ondrag,ondragtype) {
	var id = anchors.length;
	var anchor = new Kinetic.Circle({
        x: x,
        y: y,
        stroke: '#666',
        fill: '#ddd',
        strokeWidth: 2,
        radius: 4,
        draggable: true
	});
	layer.add(anchor);
	layer.draw();
	anchors.push(anchor);
	
	layer.anchors.push(anchor);

	anchor.xori = x;
	anchor.yori = y;
	anchor.active = false;
	anchor.layer = layer;
	anchorlayers.push(layer);
	anchor.dragBoundFunc(function (pos) {
		mousedrageffect = false;
		var anchorpos = {x:pos.x,y:pos.y};
		var anchorpostemp;
		anchor.active = true;
		activeanchor = this;
		if (ondrag != null) {
			if (ondragtype == "normal" || ondragtype == null) {
				anchorpostemp = ondrag({x:pos.x,y:pos.y},this);
				if (anchorpostemp != null) {
					anchorpos = anchorpostemp;
				}
			} else if (ondragtype == "absolute") {
				anchorpostemp = ondrag({x:pos.x-x,y:pos.y-y},this);
				if (anchorpostemp != null) {
					anchorpos = anchorpostemp;
				}
			}
		}
		//updateselection(layer);
		layer.ondrag = true;
		return anchorpos;
	});
	anchor.on("dragend",function() {
		mousedrageffect = true;
		anchor.active = false;
		if (activeanchor) { //Fix bug
			activeanchor.remove();
		}
	})
	anchor.on('mouseover', function() {
		document.body.style.cursor = 'pointer';
		this.setStrokeWidth(2.5);
		layer.draw();
	});
	anchor.on('mouseout', function() {
		document.body.style.cursor = 'default';
		this.strokeWidth(2);
		layer.draw();
	});
	return anchor;
}

function objremoveanchor (layer) {
	//try {
	$.each(layer.anchors,function (index,value) {
		//if (layer.type == "object") { //Fix bug
			//layer.anchors[0].remove();
			//console.log(value.active);
			if (!value.active) {
				//value.remove();
				value.remove();
			}
		/*} else {
			value.remove();
		}*/
	})
	layer.draw();
	layer.anchors = [];
	anchorlayers.splice(anchorlayers.indexOf(layer),1);
	//} catch (e) {}
}

function removeanchor (anchor) {
	anchor.remove();
	//anchor.layer.anchors.splice(anchor.layer.anchors.indexOf(anchor),1)
}

function clearanchor () {
	$.each(anchorlayers,function(index,value) {
		if (value) {
			objremoveanchor(value);
		}
	});
}

function objcreateanchor (obj) {
	if (!onrun) {
		switch (obj.type) {
			case "beam":beamanchor(obj); break;
			case "object":objectanchor(obj); break;
			case "slide":slideanchor(obj); break;
			case "force":forceanchor(obj); break;
			case "wedge":wedgeanchor(obj); break;
			case "pulley":pulleyanchor(obj); break;
		    case "wheel": wheelanchor(obj); break;
		    case "screw": screwanchor(obj); break;
			case "rope":ropeanchor(obj); break;
		}
	}
}

function updateanchor (anchor,x,y) {
	if (anchor != null) {
		anchor.setX(x);
		anchor.setY(y);
		anchor.draw();
	}
}

function objupdateanchor (obj) {
	switch (obj.type) {
		case "beam":beamanchorupdate(obj); break;
		case "object":objectanchorupdate(obj); break;
	}
}

function updateallanchor () {
	$.each(anchorlayers,function(index,value) {
		objupdateanchor(value);
	});
}

function screwanchor(screw) {
    objremoveanchor(screw);
    createanchor(screw, screw.xmin, screw.y, function (pos, anchor) {
        var oldymin = screw.y;
        screw.xmin = pos.x;
        screw.y = pos.y;
        screw.width = screw.xmax - screw.xmin;
        screw.height = stageh - 70 - screw.y;

        if (screw.width < 10) {
            screw.width = 10;
            screw.xmin = screw.xmax-10;
        }
        if (screw.height < 10) {
            screw.height = 10;
            screw.y = stageh - 80;
        }
        if (screw.xmin > screw.objcentermin && screw.objcentermin != -1) {
            screw.xmin = screw.objcentermin;
        }

        var ychange = screw.y - oldymin;

        screw.center = (screw.xmin + screw.xmax) / 2;

        updatescrew(screw);

        $.each(screw.objects, function (index, obj) {
            obj.ymin += ychange;
            obj.ymax += ychange;
            obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
            obj.draw();
        });

        return { x: screw.xmin, y: screw.y };
    });
    createanchor(screw, screw.xmax, screw.y, function (pos, anchor) {
        var oldymin = screw.y;
        screw.xmax = pos.x;
        screw.y = pos.y;
        screw.width = screw.xmax - screw.xmin;
        screw.height = stageh - 70 - screw.y;

        if (screw.width < 10) {
            screw.width = 10;
            screw.xmax = screw.xmin + 10;
        }
        if (screw.height < 10) {
            screw.height = 10;
            screw.y = stageh - 80;
        }
        if (screw.xmax < screw.objcentermax && screw.objcentermax != -1) {
            screw.xmax = screw.objcentermax;
        }

        var ychange = screw.y - oldymin;

        screw.center = (screw.xmin + screw.xmax) / 2;

        updatescrew(screw);

        $.each(screw.objects, function (index, obj) {
            obj.ymin += ychange;
            obj.ymax += ychange;
            obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
            obj.draw();
        });

        return { x: screw.xmax, y: screw.y };
    });
    createanchor(screw, (screw.xmin + screw.xmax) / 2, screw.y, function (pos, anchor) {
        var oldymin = screw.y;
        screw.y = pos.y;
        screw.height = stageh - 70 - screw.y;

        if (screw.height < 10) {
            screw.height = 10;
            screw.y = stageh - 80;
        }

        var ychange = screw.y - oldymin;

        updatescrew(screw);

        $.each(screw.objects, function (index, obj) {
            obj.ymin += ychange;
            obj.ymax += ychange;
            obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
            obj.draw();
        });

        return { x: (screw.xmin + screw.xmax) / 2, y: screw.y };
    });
    createanchor(screw, screw.xmin, ((stageh - 70) + screw.y) / 2, function (pos, anchor) {

        screw.xmin = pos.x;
        screw.width = screw.xmax - screw.xmin;

        if (screw.width < 10) {
            screw.width = 10;
            screw.xmin = screw.xmax - 10;
        }
        if (screw.xmin > screw.objcentermin && screw.objcentermin != -1) {
            screw.xmin = screw.objcentermin;
        }

        screw.center = (screw.xmin + screw.xmax) / 2;

        updatescrew(screw);

        return { x: screw.xmin, y: ((stageh - 70) + screw.y) / 2 };
    });
    createanchor(screw, screw.xmax, ((stageh - 70) + screw.y) / 2, function (pos, anchor) {
        screw.xmax = pos.x;
        screw.width = screw.xmax - screw.xmin;

        if (screw.width < 10) {
            screw.width = 10;
            screw.xmax = screw.xmin + 10;
        }
        if (screw.xmax < screw.objcentermax && screw.objcentermax != -1) {
            screw.xmax = screw.objcentermax;
        }

        screw.center = (screw.xmin + screw.xmax) / 2;

        updatescrew(screw);

        return { x: screw.xmax, y: ((stageh - 70) + screw.y) / 2 };
    });
    createanchor(screw, screw.center + screw.handd, stageh - 63, function (pos, anchor) {
        screw.handd = pos.x - screw.center;

        updatescrew(screw);

        return { x: screw.center+screw.handd, y: stageh-63 };
    });
}

function slideanchor (slide) {
	objremoveanchor(slide);
	createanchor(slide,slide.xstart,slide.ystart,function (pos,anchor) { //0
		var xstart = slide.xstart;
		var ystart = slide.ystart;
		slide.xstart = pos.x;
		slide.ystart = pos.y;
		
		var result = true;
		
		if (Math.abs(slide.xend-slide.xstart) < 30 || stageh-60-slide.ystart < 10) {
			result = false;
		}
		
		//Update equation and angle
		var angle = slide.angle;
		var equation = slide.equation;
		slide.angle = Math.atan(((stageh-60)-slide.ystart)/(Math.max(slide.xstart,slide.xend)-Math.min(slide.xstart,slide.xend)))*(180/Math.PI);
		slide.equation = Math.linearCanvas.create(slide.xstart,slide.ystart,slide.xend,stageh-60).parallelD(-4);
		
		if (result) {
			result = updateobjectslidetest(slide);
		}
		
		if (result) {
			updateobjectslide(slide);
		} else {
			slide.xstart = xstart;
			slide.ystart = ystart;
			slide.angle = angle;
			slide.equation = equation;
		}
		
		if (result) {
			slide.getChildren()[0].points([slide.xstart,slide.ystart,slide.xstart,stageh-60,slide.xend,stageh-60]);
		}
		
		return {x:slide.xstart,y:slide.ystart};
	});
	createanchor(slide,slide.xend,stageh-60,function (pos,anchor) { //1
		var xend = slide.xend;
		slide.xend = pos.x;
		
		var result = true;
		
		if (Math.abs(slide.xend-slide.xstart) < 30) {
			result = false;
		}
		
		//Update equation and angle
		var angle = slide.angle;
		var equation = slide.equation;
		slide.angle = Math.atan(((stageh-60)-slide.ystart)/(Math.max(slide.xstart,slide.xend)-Math.min(slide.xstart,slide.xend)))*(180/Math.PI);
		slide.equation = Math.linearCanvas.create(slide.xstart,slide.ystart,slide.xend,stageh-60).parallelD(-4);
		
		if (result) {
			result = updateobjectslidetest(slide);
		}
		
		if (result) {
			updateobjectslide(slide);
		} else {
			slide.xend = xend;
			slide.angle = angle;
			slide.equation = equation;
		}
		
		if (result) {
			slide.getChildren()[0].points([slide.xstart,slide.ystart,slide.xstart,stageh-60,slide.xend,stageh-60]);
		}
		
		return {x:slide.xend,y:stageh-60};
	});
	createanchor(slide,slide.xstart,((stageh-60)+slide.ystart)/2,function (pos,anchor) { //2
		var xstart = slide.xstart;
		slide.xstart = pos.x;
		
		var result = true;
		
		if (Math.abs(slide.xend-slide.xstart) < 30) {
			result = false;
		}
		
		//Update equation and angle
		var angle = slide.angle;
		var equation = slide.equation;
		slide.angle = Math.atan(((stageh-60)-slide.ystart)/(Math.max(slide.xstart,slide.xend)-Math.min(slide.xstart,slide.xend)))*(180/Math.PI);
		slide.equation = Math.linearCanvas.create(slide.xstart,slide.ystart,slide.xend,stageh-60).parallelD(-4);
		
		if (result) {
			result = updateobjectslidetest(slide);
		}
		
		if (result) {
			updateobjectslide(slide);
		} else {
			slide.xstart = xstart;
			slide.angle = angle;
			slide.equation = equation;
		}
		
		if (result) {
			slide.getChildren()[0].points([slide.xstart,slide.ystart,slide.xstart,stageh-60,slide.xend,stageh-60]);
		}
		
		return {x:slide.xstart,y:((stageh-60)+slide.ystart)/2};
	});
}

function forceanchor (f) {
	objremoveanchor(f);
	createanchor(f,f.xend,f.yend,function(pos,anchor) {
		f.xend = pos.x;
		f.yend = pos.y;
		
		f.d = Math.linear.getPointDistance(f.xstart,f.ystart,f.xend,f.yend,true);
		if (!f.lockangle) {
			f.angle = Math.getAngleFromTwoPoint(f.xstart,f.ystart,f.xend,f.yend,true);
		} else {
			forcerotate(f,f.angle);
		}
		
		switch (f.instanceof.type) {
			case "beam":
				if ((f.up && !(f.angle <= 90 || f.angle >= 270)) || (!f.up && !(f.angle >= 90 && f.angle <= 270))) {
					f.yend = f.ystart;
					
					f.angle = Math.getAngleFromTwoPoint(f.xstart,f.ystart,f.xend,f.yend,true);
					f.d = Math.linear.getPointDistance(f.xstart,f.ystart,f.xend,f.yend,true);
				}
		}
		
		f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart,f.xend,f.yend,f.reverse));
		f.draw();
		
		return {x:f.xend,y:f.yend};
	});
	//console.log(f.anchors);
}

function objectanchor (obj) {
	objremoveanchor(obj);
	switch (obj.instanceof.type) {
		case "slide":
			var slide = obj.instanceof;
			var points = obj.getChildren()[0].points();
			createanchor(obj,points[0],points[1],function(pos,anchor) {//0
				var x = pos.x;
				var y = pos.y;
				
				//console.log(slide.equation);
				
				var line1 = slide.equation.perpendicular(points[4],points[5]);
				var line2 = slide.equation.perpendicular(x,y);
				var line3 = line1.perpendicular(x,y);
				var point1 = line3.intersection(line1);
				var point2 = line1.intersection(slide.equation);
				var point3 = line2.intersection(slide.equation);
				
				obj.width = line1.getparallelD(line2);
				obj.height = slide.equation.getparallelD(line3);
				obj.center = line1.parallelD(obj.width/2).intersection(slide.equation);
				obj.dfromend = Math.linear.getPointDistance(obj.center.x,obj.center.y,slide.xend,stageh-60,true);
				
				obj.anchors[1].x = line3.x;
				obj.anchors[1].y = line3.y;

				obj.getChildren()[0].points([point1.x, point1.y, point2.x, point2.y, point3.x, point3.y, x, y]);
			});
			createanchor(obj,points[6],points[7],function(pos,anchor) {//1
				var x = pos.x;
				var y = pos.y;
				
				//console.log(slide.equation);
				
				var line1 = slide.equation.perpendicular(points[2],points[3]);
				var line2 = slide.equation.perpendicular(x,y);
				var line3 = line1.perpendicular(x,y);
				var point1 = line3.intersection(line1);
				var point2 = line1.intersection(slide.equation);
				var point3 = line2.intersection(slide.equation);
				
				obj.width = line1.getparallelD(line2);
				obj.height = slide.equation.getparallelD(line3);
				obj.center = line1.parallelD(obj.width/2).intersection(slide.equation);
				obj.dfromend = Math.linear.getPointDistance(obj.center.x,obj.center.y,slide.xend,stageh-60,true);
				
				obj.anchors[0].x = line3.x;
				obj.anchors[0].y = line3.y;

				obj.getChildren()[0].points([point1.x, point1.y, point2.x, point2.y, point3.x, point3.y, x, y]);
			});
			break;
		case "beam":
			//corner
			createanchor(obj,obj.xmin,obj.ymin,function(pos,anchor) {//0
				obj.xmin = pos.x;
				obj.ymin = pos.y;
				
				if ((obj.xmax+obj.xmin)/2 < obj.instanceof.xmin) {
					obj.xmin = obj.instanceof.xmin-(obj.xmax-obj.instanceof.xmin);
				}
				
				if (obj.ymax-obj.ymin < 10) {
					obj.ymin = obj.ymax-10;
				}
				
				if (obj.xmax-obj.xmin < 10) {
					obj.xmin = obj.xmax-10;
				}
				
				obj.getChildren()[0].points()[0] = obj.xmin;
				obj.getChildren()[0].points()[2] = obj.xmin;
				obj.getChildren()[0].points()[1] = obj.ymin;
				obj.getChildren()[0].points()[7] = obj.ymin;
				
				obj.anchors[1].setY(obj.ymin);
				//center
				obj.anchors[2].setX((obj.xmax+obj.xmin)/2);
				obj.anchors[2].setY(obj.ymin);
				obj.anchors[3].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[3].setX(obj.xmin);
				obj.anchors[4].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[4].setX(obj.xmax);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:obj.xmin,y:obj.ymin};
			});
			createanchor(obj,obj.xmax,obj.ymin,function(pos,anchor) {//1
				obj.xmax = pos.x;
				obj.ymin = pos.y;
				
				if ((obj.xmax+obj.xmin)/2 > obj.instanceof.xmax) {
					obj.xmax = obj.instanceof.xmax+(obj.instanceof.xmax-obj.xmin);
				}
				
				if (obj.ymax-obj.ymin < 10) {
					obj.ymin = obj.ymax-10;
				}
				
				if (obj.xmax-obj.xmin < 10) {
					obj.xmax = obj.xmin+10;
				}
				
				obj.getChildren()[0].points()[4] = obj.xmax;
				obj.getChildren()[0].points()[6] = obj.xmax;
				obj.getChildren()[0].points()[1] = obj.ymin;
				obj.getChildren()[0].points()[7] = obj.ymin;
				
				obj.anchors[0].setY(obj.ymin);
				//center
				obj.anchors[2].setX((obj.xmax+obj.xmin)/2);
				obj.anchors[2].setY(obj.ymin);
				obj.anchors[3].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[3].setX(obj.xmin);
				obj.anchors[4].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[4].setX(obj.xmax);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:obj.xmax,y:obj.ymin};
			});
			
			//center
			createanchor(obj,(obj.xmax+obj.xmin)/2,obj.ymin,function(pos,anchor) {//2
				obj.ymin = pos.y;
				
				if (obj.ymax-obj.ymin < 10) {
					obj.ymin = obj.ymax-10;
				}
				
				obj.getChildren()[0].points()[1] = obj.ymin;
				obj.getChildren()[0].points()[7] = obj.ymin;
				
				obj.anchors[0].setY(obj.ymin);
				obj.anchors[1].setY(obj.ymin);
				//center
				obj.anchors[3].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[4].setY((obj.ymax+obj.ymin)/2);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:anchor.xori,y:obj.ymin};
			});
			createanchor(obj,obj.xmin,(obj.ymax+obj.ymin)/2,function(pos,anchor) {//3
				obj.xmin = pos.x;
				
				if ((obj.xmax+obj.xmin)/2 < obj.instanceof.xmin) {
					obj.xmin = obj.instanceof.xmin-(obj.xmax-obj.instanceof.xmin);
				}
				
				if (obj.xmax-obj.xmin < 10) {
					obj.xmin = obj.xmax-10;
				}
				
				obj.getChildren()[0].points()[0] = obj.xmin;
				obj.getChildren()[0].points()[2] = obj.xmin;
				
				obj.anchors[0].setX(obj.xmin);
				//center
				obj.anchors[2].setX((obj.xmax+obj.xmin)/2);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:obj.xmin,y:anchor.yori};
			});
			createanchor(obj,obj.xmax,(obj.ymax+obj.ymin)/2,function(pos,anchor) {//4
				obj.xmax = pos.x;
				
				if ((obj.xmax+obj.xmin)/2 > obj.instanceof.xmax) {
					obj.xmax = obj.instanceof.xmax+(obj.instanceof.xmax-obj.xmin);
				}
				
				if (obj.xmax-obj.xmin < 10) {
					obj.xmax = obj.xmin+10;
				}
				
				obj.getChildren()[0].points()[4] = obj.xmax;
				obj.getChildren()[0].points()[6] = obj.xmax;
				
				obj.anchors[1].setX(obj.xmax);
				//center
				obj.anchors[2].setX((obj.xmax+obj.xmin)/2);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:obj.xmax,y:anchor.yori};
			});
			break;
		case "wedge":
			//corner
			createanchor(obj,obj.xmin,obj.ymin,function(pos,anchor) {//0
				obj.xmin = pos.x;
				obj.ymin = pos.y;
				
				if ((obj.xmax+obj.xmin)/2 < obj.instanceof.xstart) {
					obj.xmin = obj.instanceof.xstart-(obj.xmax-obj.instanceof.xstart);
				}
				
				if (obj.ymax-obj.ymin < 10) {
					obj.ymin = obj.ymax-10;
				}
				
				if (obj.xmax-obj.xmin < 10) {
					obj.xmin = obj.xmax-10;
				}
				
				obj.getChildren()[0].points()[0] = obj.xmin;
				obj.getChildren()[0].points()[2] = obj.xmin;
				obj.getChildren()[0].points()[1] = obj.ymin;
				obj.getChildren()[0].points()[7] = obj.ymin;
				
				obj.anchors[1].setY(obj.ymin);
				//center
				obj.anchors[2].setX((obj.xmax+obj.xmin)/2);
				obj.anchors[2].setY(obj.ymin);
				obj.anchors[3].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[3].setX(obj.xmin);
				obj.anchors[4].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[4].setX(obj.xmax);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:obj.xmin,y:obj.ymin};
			});
			createanchor(obj,obj.xmax,obj.ymin,function(pos,anchor) {//1
				obj.xmax = pos.x;
				obj.ymin = pos.y;
				
				if ((obj.xmax+obj.xmin)/2 > obj.instanceof.xend) {
					obj.xmax = obj.instanceof.xend+(obj.instanceof.xend-obj.xmin);
				}
				
				if (obj.ymax-obj.ymin < 10) {
					obj.ymin = obj.ymax-10;
				}
				
				if (obj.xmax-obj.xmin < 10) {
					obj.xmax = obj.xmin+10;
				}
				
				obj.getChildren()[0].points()[4] = obj.xmax;
				obj.getChildren()[0].points()[6] = obj.xmax;
				obj.getChildren()[0].points()[1] = obj.ymin;
				obj.getChildren()[0].points()[7] = obj.ymin;
				
				obj.anchors[0].setY(obj.ymin);
				//center
				obj.anchors[2].setX((obj.xmax+obj.xmin)/2);
				obj.anchors[2].setY(obj.ymin);
				obj.anchors[3].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[3].setX(obj.xmin);
				obj.anchors[4].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[4].setX(obj.xmax);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:obj.xmax,y:obj.ymin};
			});
			
			//center
			createanchor(obj,(obj.xmax+obj.xmin)/2,obj.ymin,function(pos,anchor) {//2
				obj.ymin = pos.y;
				
				if (obj.ymax-obj.ymin < 10) {
					obj.ymin = obj.ymax-10;
				}
				
				obj.getChildren()[0].points()[1] = obj.ymin;
				obj.getChildren()[0].points()[7] = obj.ymin;
				
				obj.anchors[0].setY(obj.ymin);
				obj.anchors[1].setY(obj.ymin);
				//center
				obj.anchors[3].setY((obj.ymax+obj.ymin)/2);
				obj.anchors[4].setY((obj.ymax+obj.ymin)/2);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:anchor.xori,y:obj.ymin};
			});
			createanchor(obj,obj.xmin,(obj.ymax+obj.ymin)/2,function(pos,anchor) {//3
				obj.xmin = pos.x;
				
				if ((obj.xmax+obj.xmin)/2 < obj.instanceof.xstart) {
					obj.xmin = obj.instanceof.xstart-(obj.xmax-obj.instanceof.xstart);
				}
				
				if (obj.xmax-obj.xmin < 10) {
					obj.xmin = obj.xmax-10;
				}
				
				obj.getChildren()[0].points()[0] = obj.xmin;
				obj.getChildren()[0].points()[2] = obj.xmin;
				
				obj.anchors[0].setX(obj.xmin);
				//center
				obj.anchors[2].setX((obj.xmax+obj.xmin)/2);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:obj.xmin,y:anchor.yori};
			});
			createanchor(obj,obj.xmax,(obj.ymax+obj.ymin)/2,function(pos,anchor) {//4
				obj.xmax = pos.x;
				
				if ((obj.xmax+obj.xmin)/2 > obj.instanceof.xend) {
					obj.xmax = obj.instanceof.xend+(obj.instanceof.xend-obj.xmin);
				}
				
				if (obj.xmax-obj.xmin < 10) {
					obj.xmax = obj.xmin+10;
				}
				
				obj.getChildren()[0].points()[4] = obj.xmax;
				obj.getChildren()[0].points()[6] = obj.xmax;
				
				obj.anchors[1].setX(obj.xmax);
				//center
				obj.anchors[2].setX((obj.xmax+obj.xmin)/2);
				
				obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
				
				return {x:obj.xmax,y:anchor.yori};
			});
			break;
	    case "screw":
	        createanchor(obj, obj.xmin, obj.ymin, function (pos, anchor) {//0
	            obj.xmin = pos.x;
	            obj.ymin = pos.y;

	            if (obj.ymax - obj.ymin < 10) {
	                obj.ymin = obj.ymax - 10;
	            }
	            if (obj.xmax - obj.xmin < 10) {
	                obj.xmin = obj.xmax - 10;
	            }

	            obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
	            obj.draw();
	            obj.width = obj.xmax - obj.xmin;
	            obj.height = obj.ymax - obj.ymin;

	            obj.anchors[1].setX(obj.xmax);
	            obj.anchors[1].setY(obj.ymax);

	            return { x: obj.xmin, y: obj.ymin };
	        });
	        createanchor(obj, obj.xmax, obj.ymin, function (pos, anchor) {//1
	            obj.xmax = pos.x;
	            obj.ymin = pos.y;

	            if (obj.ymin - obj.ymin < 10) {
	                obj.ymin = obj.ymax - 10;
	            }
	            if (obj.xmax - obj.xmin < 10) {
	                obj.xmax = obj.xmin + 10;
	            }

	            obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
	            obj.draw();
	            obj.width = widthdiv2 * 2;
	            obj.height = obj.ymax - obj.ymin;

	            obj.anchors[0].setX(obj.xmax - obj.xmin);
	            obj.anchors[0].setY(obj.ymax);

	            return { x: obj.xmax, y: obj.ymin };
	        });
	        break;
		case "rope":
		    createanchor(obj, obj.xmin, obj.ymax, function (pos, anchor) {//0
		        var widthdiv2 = (obj.center - pos.x);

			    if (widthdiv2 < 5) {
			        widthdiv2 = 5;
			    }

			    obj.xmin = obj.center - widthdiv2;
			    obj.xmax = obj.center + widthdiv2;
			    obj.ymax = pos.y;

			    if (obj.ymax - obj.ymin < 10) {
			        obj.ymax = obj.ymin + 10;
			    }

			    obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
			    obj.draw();
			    obj.width = widthdiv2 * 2;
			    obj.height = obj.ymax - obj.ymin;

			    obj.anchors[1].setX(obj.xmax);
			    obj.anchors[1].setY(obj.ymax);
                
			    return { x: obj.xmin, y: obj.ymax };
			});
			createanchor(obj, obj.xmax, obj.ymax, function (pos, anchor) {//1
			    var widthdiv2 = (pos.x - obj.center);

			    if (widthdiv2 < 5) {
			        widthdiv2 = 5;
			    }

			    obj.xmin = obj.center - widthdiv2;
			    obj.xmax = obj.center + widthdiv2;
			    obj.ymax = pos.y;

			    if (obj.ymax - obj.ymin < 10) {
			        obj.ymax = obj.ymin + 10;
			    }

			    obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
			    obj.draw();
			    obj.width = widthdiv2 * 2;
			    obj.height = obj.ymax - obj.ymin;

			    obj.anchors[0].setX(obj.xmin);
			    obj.anchors[0].setY(obj.ymax);

			    return { x: obj.xmax, y: obj.ymax };
			});
			break;
	}
}

function objectanchorupdate (obj) {
	
}

function wedgeanchor (wedge) {
	objremoveanchor(wedge);
	createanchor(wedge,wedge.xstart,wedge.ystart,function (pos,anchor) { //0
		var yold = wedge.ystart;
		wedge.xstart = pos.x;
		wedge.ystart = pos.y;
		
		if (wedge.xstart>wedge.objcentermin && wedge.objcentermin != -1) {
			wedge.xstart = wedge.objcentermin;
		}
		
		if (wedge.xstart > wedge.xend-10) {
			wedge.xstart = wedge.xend-10;
		}
		if (wedge.ystart > stageh-75) {
			wedge.ystart = stageh-75;
		}
		
		wedge.getChildren()[0].points([wedge.xstart,wedge.ystart,wedge.xend,wedge.ystart,(wedge.xstart+wedge.xend)/2,stageh-63]);
		wedge.draw();
		
		var ychange = wedge.ystart-yold;
		
		$.each(wedge.objects,function(index,obj) {
			obj.ymin += ychange;
			obj.ymax += ychange;
			obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
			obj.draw();
		});
		
		wedge.width = wedge.xend-wedge.xstart;
		wedge.height = stageh-63-wedge.ystart;
		
		return {x:wedge.xstart,y:wedge.ystart};
		
	});
	createanchor(wedge,wedge.xend,wedge.ystart,function (pos,anchor) { //1
		var yold = wedge.ystart;
		wedge.xend = pos.x;
		wedge.ystart = pos.y;
		
		if (wedge.xend<wedge.objcentermax && wedge.objcentermax != -1) {
			wedge.xend = wedge.objcentermax;
		}
		
		if (wedge.xend < wedge.xstart+10) {
			wedge.xend = wedge.xstart+10;
		}
		if (wedge.ystart > stageh-75) {
			wedge.ystart = stageh-75;
		}
		
		wedge.getChildren()[0].points([wedge.xstart,wedge.ystart,wedge.xend,wedge.ystart,(wedge.xstart+wedge.xend)/2,stageh-63]);
		wedge.draw();
		
		var ychange = wedge.ystart-yold;
		
		$.each(wedge.objects,function(index,obj) {
			obj.ymin += ychange;
			obj.ymax += ychange;
			obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
			obj.draw();
		});
		
		wedge.width = wedge.xend-wedge.xstart;
		wedge.height = stageh-63-wedge.ystart;
		
		return {x:wedge.xend,y:wedge.ystart};
		
	});
	createanchor(wedge,(wedge.xstart+wedge.xend)/2,wedge.ystart,function (pos,anchor) { //0
		var yold = wedge.ystart;
		wedge.ystart = pos.y;

		if (wedge.ystart > stageh-75) {
			wedge.ystart = stageh-75;
		}
		
		wedge.getChildren()[0].points([wedge.xstart,wedge.ystart,wedge.xend,wedge.ystart,(wedge.xstart+wedge.xend)/2,stageh-63]);
		wedge.draw();
		
		var ychange = wedge.ystart-yold;
		
		$.each(wedge.objects,function(index,obj) {
			obj.ymin += ychange;
			obj.ymax += ychange;
			obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
			obj.draw();
		});
		
		wedge.height = stageh-63-wedge.ystart;
		
		return {x:(wedge.xstart+wedge.xend)/2,y:wedge.ystart};
		
	});
	
}

function wheelanchor (wheel) {
	objremoveanchor(wheel);
	createanchor(wheel,wheel.center.x,wheel.center.y+wheel.r,function (pos,anchor) {
		wheel.r = pos.y-wheel.center.y;
		
		if (wheel.r < wheel.rinner+5) {
			wheel.r = wheel.rinner+5;
		}
		if (wheel.r < 5) {
			wheel.r = 5;
		}
		
		wheel.getChildren()[0].setRadius(wheel.r);
		wheelupdaterope(wheel);
		wheel.draw();
		
		return {x:wheel.center.x,y:wheel.center.y+wheel.r};
	});
	createanchor(wheel,wheel.center.x,wheel.center.y-wheel.r,function (pos,anchor) {
		wheel.r = wheel.center.y-pos.y;
		
		if (wheel.r < wheel.rinner+5) {
			wheel.r = wheel.rinner+5;
		}
		if (wheel.r < 5) {
			wheel.r = 5;
		}
		
		wheel.getChildren()[0].setRadius(wheel.r);
		wheelupdaterope(wheel);
		wheel.draw();
		
		return {x:wheel.center.x,y:wheel.center.y-wheel.r};
	});
	createanchor(wheel,wheel.center.x+wheel.r,wheel.center.y,function (pos,anchor) {
		wheel.r = pos.x-wheel.center.x;
		
		if (wheel.r < wheel.rinner+5) {
			wheel.r = wheel.rinner+5;
		}
		if (wheel.r < 5) {
			wheel.r = 5;
		}
		
		wheel.getChildren()[0].setRadius(wheel.r);
		wheelupdaterope(wheel);
		wheel.draw();
		
		return {x:wheel.center.x+wheel.r,y:wheel.center.y};
	});
	createanchor(wheel,wheel.center.x-wheel.r,wheel.center.y,function (pos,anchor) {
		wheel.r = wheel.center.x-pos.x;
		
		if (wheel.r < wheel.rinner+5) {
			wheel.r = wheel.rinner+5;
		}
		if (wheel.r < 5) {
			wheel.r = 5;
		}
		
		wheel.getChildren()[0].setRadius(wheel.r);
		wheelupdaterope(wheel);
		wheel.draw();
		
		return {x:wheel.center.x-wheel.r,y:wheel.center.y};
	});
	
	createanchor(wheel,wheel.center.x,wheel.center.y+wheel.rinner,function (pos,anchor) {
		wheel.rinner = pos.y-wheel.center.y;
		
		if (wheel.rinner > wheel.r-5) {
			wheel.rinner = wheel.r-5;
		}
		if (wheel.rinner < 5) {
			wheel.rinner = 5;
		}
		
		wheel.getChildren()[1].setRadius(wheel.rinner);
		wheelupdaterope(wheel);
		wheel.draw();
		
		return {x:wheel.center.x,y:wheel.center.y+wheel.rinner};
	});
	createanchor(wheel,wheel.center.x,wheel.center.y-wheel.rinner,function (pos,anchor) {
		wheel.rinner = wheel.center.y-pos.y;
		
		if (wheel.rinner > wheel.r-5) {
			wheel.rinner = wheel.r-5;
		}
		if (wheel.rinner < 5) {
			wheel.rinner = 5;
		}
		
		wheel.getChildren()[1].setRadius(wheel.rinner);
		wheelupdaterope(wheel);
		wheel.draw();
		
		return {x:wheel.center.x,y:wheel.center.y-wheel.rinner};
	});
	createanchor(wheel,wheel.center.x+wheel.rinner,wheel.center.y,function (pos,anchor) {
		wheel.rinner = pos.x-wheel.center.x;
		
		if (wheel.rinner > wheel.r-5) {
			wheel.rinner = wheel.r-5;
		}
		if (wheel.rinner < 5) {
			wheel.rinner = 5;
		}
		
		wheel.getChildren()[1].setRadius(wheel.rinner);
		wheelupdaterope(wheel);
		wheel.draw();
		
		return {x:wheel.center.x+wheel.rinner,y:wheel.center.y};
	});
	createanchor(wheel,wheel.center.x-wheel.rinner,wheel.center.y,function (pos,anchor) {
		wheel.rinner = wheel.center.x-pos.x;
		
		if (wheel.rinner > wheel.r-5) {
			wheel.rinner = wheel.r-5;
		}
		if (wheel.rinner < 5) {
			wheel.rinner = 5;
		}
		
		wheel.getChildren()[1].setRadius(wheel.rinner);
		wheelupdaterope(wheel);
		wheel.draw();
		
		return {x:wheel.center.x-wheel.rinner,y:wheel.center.y};
	});
}

function pulleyanchor (pulley) {
	objremoveanchor(pulley);
	createanchor(pulley,pulley.center.x,pulley.center.y+pulley.r,function (pos,anchor) {
		pulley.r = pos.y-pulley.center.y;
		
		if (pulley.r < 5) {
			pulley.r = 5;
		}
		
		pulley.getChildren()[0].setRadius(pulley.r);
		pulleyupdaterope(pulley);
		pulley.draw();
		
		return {x:pulley.center.x,y:pulley.center.y+pulley.r};
	});
	createanchor(pulley,pulley.center.x,pulley.center.y-pulley.r,function (pos,anchor) {
		pulley.r = pulley.center.y-pos.y;
		
		if (pulley.r < 5) {
			pulley.r = 5;
		}
		
		pulley.getChildren()[0].setRadius(pulley.r);
		pulleyupdaterope(pulley);
		pulley.draw();
		
		return {x:pulley.center.x,y:pulley.center.y-pulley.r};
	});
	createanchor(pulley,pulley.center.x+pulley.r,pulley.center.y,function (pos,anchor) {
		pulley.r = pos.x-pulley.center.x;
		
		if (pulley.r < 5) {
			pulley.r = 5;
		}
		
		pulley.getChildren()[0].setRadius(pulley.r);
		pulleyupdaterope(pulley);
		pulley.draw();
		
		return {x:pulley.center.x+pulley.r,y:pulley.center.y};
	});
	createanchor(pulley,pulley.center.x-pulley.r,pulley.center.y,function (pos,anchor) {
		pulley.r = pulley.center.x-pos.x;
		
		if (pulley.r < 5) {
			pulley.r = 5;
		}
		
		pulley.getChildren()[0].setRadius(pulley.r);
		pulleyupdaterope(pulley);
		pulley.draw();
		
		return {x:pulley.center.x-pulley.r,y:pulley.center.y};
	});
}

function ropeanchor (rope) {
    objremoveanchor(rope);
    if (!rope.locked) {
        createanchor(rope, rope.xend, rope.yend, function (pos, anchor) {
            if (((rope.up && pos.y < rope.ystart) || (!rope.up && pos.y > rope.ystart)) && (Math.abs(pos.y - rope.ystart) >= 5)) {
                rope.yend = pos.y;
                rope.getChildren()[0].points([rope.xstart, rope.ystart, rope.xend, rope.yend]);
                rope.d = Math.linear.getPointDistance(rope.xstart, rope.ystart, rope.xend, rope.yend, true);
                rope.draw();

                $.each(rope.objects, function (index, obj) {
                    obj.xmin = obj.instanceof.xend - obj.width / 2;
                    obj.ymin = obj.instanceof.yend;
                    obj.xmax = obj.instanceof.xend + obj.width / 2;
                    obj.ymax = obj.instanceof.yend + obj.height;
                    obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
                    setTimeout(function () {
                        obj.draggable(false);
                    }, 10);
                    obj.draw();
                });

                $.each(rope.forces, function (index, f) {
                    if (f.instanceof.up) {
                        f.xstart = f.instanceof.xend;
                        f.ystart = f.instanceof.yend;
                        f.xend = f.instanceof.xend;
                        f.yend = f.instanceof.yend - f.d;
                    } else {
                        f.xstart = f.instanceof.xend;
                        f.ystart = f.instanceof.yend;
                        f.xend = f.instanceof.xend;
                        f.yend = f.instanceof.yend + f.d;
                    }
                    f.getChildren()[0].points(arrowpoint(f.xstart, f.ystart, f.xend, f.yend, f.reverse));
                    setTimeout(function () {
                        f.draggable(false);
                    }, 10);
                    f.draw();
                });
            }
            return { x: rope.xend, y: rope.yend };
        });
    }
}

function beamanchor (beam) {
	objremoveanchor(beam);
	//fulcrum anchor
	createanchor(beam,beam.fulcrum,beam.ymax,function (pos,anchor) { //0
		//var ychange = pos.y-beam.ymax;
		
		//beam.ymin = pos.y-(beam.ymax-beam.ymin);
		beam.ymax = pos.y;
		
		if (beam.ymax<beam.ymin+10) {
			beam.ymax = beam.ymin+10;
		}
		
		if ((stageh-60)-beam.ymax<10) {
			beam.ymax = stageh-70;
		}
		
		//beam.getChildren()[1].points()[1] = beam.ymin;
		//beam.getChildren()[1].points()[7] = beam.ymin;
		beam.getChildren()[1].points()[3] = beam.ymax;
		beam.getChildren()[1].points()[5] = beam.ymax;
		
		beam.getChildren()[0].setY(beam.ymax+(2/3*(stageh-60-beam.ymax)));
		beam.getChildren()[0].setRadius(2/3*(stageh-60-beam.ymax));
		
		beam.anchors[1].setY(beam.ymax);
		//beam.anchors[2].setY(beam.ymin);
		beam.anchors[3].setY(beam.ymax);
		//beam.anchors[4].setY(beam.ymin);
		//beam.anchors[5].setY(beam.ymin);
		//center
		beam.anchors[6].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[7].setY((beam.ymax+beam.ymin)/2);
		beam.draw();
		
		//Update obj
		/*$.each(beam.objects,function(index,obj) {
			obj.ymin += ychange;
			obj.ymax += ychange;
			obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
			obj.draw();
		});*/
		
		return {x:anchor.xori,y:beam.ymax};
	});
	
	//corner anchor
	createanchor(beam,beam.xmax,beam.ymax,function (pos,anchor) { //1
		
		beam.ymax = pos.y;
		beam.xmax = pos.x;
		
		if (beam.xmax<beam.objcentermax && beam.objcentermax != -1) {
			beam.xmax = beam.objcentermax;
		}
		
		if (beam.ymax<beam.ymin+10) {
			beam.ymax = beam.ymin+10;
		}
		
		if (beam.xmax<beam.xmin+10) {
			beam.xmax = beam.xmin+10;
		}
		if (beam.xmax<beam.fulcrum) {
			beam.xmax = beam.fulcrum;
		}
		
		//beam.getChildren()[1].points()[1] = beam.ymin;
		//beam.getChildren()[1].points()[7] = beam.ymin;
		beam.getChildren()[1].points()[3] = beam.ymax;
		beam.getChildren()[1].points()[5] = beam.ymax;
		beam.getChildren()[1].points()[4] = beam.xmax;
		beam.getChildren()[1].points()[6] = beam.xmax;
		
		beam.getChildren()[0].setY(beam.ymax+(2/3*(stageh-60-beam.ymax)));
		beam.getChildren()[0].setRadius(2/3*(stageh-60-beam.ymax));
		
		beam.anchors[0].setY(beam.ymax);
		beam.anchors[2].setX(beam.xmax);
		beam.anchors[3].setY(beam.ymax);
		//center
		beam.anchors[5].setX((beam.xmax+beam.xmin)/2);
		beam.anchors[5].setY(beam.ymin);
		beam.anchors[6].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[6].setX(beam.xmin);
		beam.anchors[7].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[7].setX(beam.xmax);
		beam.draw();
		
		return {x:beam.xmax,y:beam.ymax};
	});
	createanchor(beam,beam.xmax,beam.ymin,function (pos) { //2
		var oldymin = beam.ymin;
		beam.xmax = pos.x;
		beam.ymin = pos.y;
		
		if (beam.xmax<beam.objcentermax && beam.objcentermax != -1) {
			beam.xmax = beam.objcentermax;
		}
		
		if (beam.ymin>beam.ymax-10) {
			beam.ymin = beam.ymax-10;
		}
		
		if (beam.xmax<beam.xmin+10) {
			beam.xmax = beam.xmin+10;
		}
		if (beam.xmax<beam.fulcrum) {
			beam.xmax = beam.fulcrum;
		}
		
		var ychange = beam.ymin-oldymin;
		
		beam.getChildren()[1].points()[4] = beam.xmax;
		beam.getChildren()[1].points()[1] = beam.ymin;
		beam.getChildren()[1].points()[6] = beam.xmax;
		beam.getChildren()[1].points()[7] = beam.ymin;
		
		beam.anchors[4].setY(beam.ymin);
		beam.anchors[1].setX(beam.xmax);
		//center
		beam.anchors[5].setX((beam.xmax+beam.xmin)/2);
		beam.anchors[5].setY(beam.ymin);
		beam.anchors[6].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[6].setX(beam.xmin);
		beam.anchors[7].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[7].setX(beam.xmax);
		beam.draw();
		
		$.each(beam.objects,function(index,obj) {
			obj.ymin += ychange;
			obj.ymax += ychange;
			obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
			obj.draw();
		});
		
		return {x:beam.xmax,y:beam.ymin};
	});
	createanchor(beam,beam.xmin,beam.ymax,function (pos,anchor) { //3
		
		beam.ymax = pos.y;
		beam.xmin = pos.x;
		
		if (beam.xmin>beam.objcentermin && beam.objcentermin != -1) {
			beam.xmin = beam.objcentermin;
		}
		
		if (beam.ymax<beam.ymin+10) {
			beam.ymax = beam.ymin+10;
		}
		
		if (beam.xmin>beam.xmax-10) {
			beam.xmin = beam.xmax-10;
		}
		if (beam.xmin>beam.fulcrum) {
			beam.xmin = beam.fulcrum;
		}
		
		beam.getChildren()[1].points()[1] = beam.ymin;
		beam.getChildren()[1].points()[7] = beam.ymin;
		beam.getChildren()[1].points()[3] = beam.ymax;
		beam.getChildren()[1].points()[5] = beam.ymax;
		beam.getChildren()[1].points()[0] = beam.xmin;
		beam.getChildren()[1].points()[2] = beam.xmin;
		
		beam.getChildren()[0].setY(beam.ymax+(2/3*(stageh-60-beam.ymax)));
		beam.getChildren()[0].setRadius(2/3*(stageh-60-beam.ymax));
		
		beam.anchors[0].setY(beam.ymax);
		beam.anchors[4].setX(beam.xmin);
		beam.anchors[3].setY(beam.ymax);
		//center
		beam.anchors[5].setX((beam.xmax+beam.xmin)/2);
		beam.anchors[5].setY(beam.ymin);
		beam.anchors[6].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[6].setX(beam.xmin);
		beam.anchors[7].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[7].setX(beam.xmax);
		beam.draw();
		
		return {x:beam.xmin,y:beam.ymax};
	});
	createanchor(beam,beam.xmin,beam.ymin,function (pos) { //4
		var oldymin = beam.ymin;
		beam.xmin = pos.x;
		beam.ymin = pos.y;
		
		if (beam.xmin>beam.objcentermin && beam.objcentermin != -1) {
			beam.xmin = beam.objcentermin;
		}
		
		if (beam.ymin>beam.ymax-10) {
			beam.ymin = beam.ymax-10;
		}
		
		if (beam.xmin>beam.xmax-10) {
			beam.xmin = beam.xmax-10;
		}
		if (beam.xmin>beam.fulcrum) {
			beam.xmin = beam.fulcrum;
		}
		
		var ychange = beam.ymin-oldymin;
		
		beam.getChildren()[1].points()[0] = beam.xmin;
		beam.getChildren()[1].points()[1] = beam.ymin;
		beam.getChildren()[1].points()[2] = beam.xmin;
		beam.getChildren()[1].points()[7] = beam.ymin;
		
		beam.anchors[2].setY(beam.ymin);
		beam.anchors[3].setX(beam.xmin);
		//center
		beam.anchors[5].setX((beam.xmax+beam.xmin)/2);
		beam.anchors[5].setY(beam.ymin);
		beam.anchors[6].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[6].setX(beam.xmin);
		beam.anchors[7].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[7].setX(beam.xmax);
		beam.draw();
		
		$.each(beam.objects,function(index,obj) {
			obj.ymin += ychange;
			obj.ymax += ychange;
			obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
			obj.draw();
		});
		
		return {x:beam.xmin,y:beam.ymin};
	});
	
	//center
	createanchor(beam,(beam.xmax+beam.xmin)/2,beam.ymin,function (pos,anchor) { //5
		//beam.ymax = pos.y+(beam.ymax-beam.ymin);
		var oldymin = beam.ymin;
		beam.ymin = pos.y;
		
		if (beam.ymin>beam.ymax-10) {
			beam.ymin = beam.ymax-10;
		}
		
		var ychange = beam.ymin-oldymin;
		
		beam.getChildren()[1].points()[1] = beam.ymin;
		beam.getChildren()[1].points()[7] = beam.ymin;
		//beam.getChildren()[1].points()[3] = beam.ymax;
		//beam.getChildren()[1].points()[5] = beam.ymax;
		
		//beam.getChildren()[0].setY(beam.ymax+(2/3*(stageh-60-beam.ymax)));
		//beam.getChildren()[0].setRadius(2/3*(stageh-60-beam.ymax));
		
		//beam.anchors[0].setY(beam.ymax);
		//beam.anchors[1].setY(beam.ymax);
		beam.anchors[2].setY(beam.ymin);
		//beam.anchors[3].setY(beam.ymax);
		beam.anchors[4].setY(beam.ymin);
		//center
		beam.anchors[6].setY((beam.ymax+beam.ymin)/2);
		beam.anchors[7].setY((beam.ymax+beam.ymin)/2);
		beam.draw();
		
		//Update obj
		$.each(beam.objects,function(index,obj) {
			obj.ymin += ychange;
			obj.ymax += ychange;
			obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
			obj.draw();
		});
		
		return {x:anchor.xori,y:beam.ymin};
	});
	createanchor(beam,beam.xmin,(beam.ymax+beam.ymin)/2,function (pos,anchor) { //6
		//var xchange = pos.x-beam.xmin;
		
		//beam.xmax = pos.x+(beam.xmax-beam.xmin);
		beam.xmin = pos.x;
		
		if (beam.xmin>beam.objcentermin && beam.objcentermin != -1) {
			beam.xmin = beam.objcentermin;
		}
		
		if (beam.xmin>beam.xmax-10) {
			beam.xmin = beam.xmax-10;
		}
		if (beam.xmin>beam.fulcrum) {
			beam.xmin = beam.fulcrum;
		}
		
		beam.getChildren()[1].points()[0] = beam.xmin;
		beam.getChildren()[1].points()[2] = beam.xmin;
		//beam.getChildren()[1].points()[4] = beam.xmax;
		//beam.getChildren()[1].points()[6] = beam.xmax;
		
		//beam.anchors[0].setX(beam.ymax);
		//beam.anchors[1].setX(beam.ymax);
		beam.anchors[3].setX(beam.xmin);
		//beam.anchors[3].setX(beam.ymax);
		beam.anchors[4].setX(beam.xmin);
		//center
		beam.anchors[5].setX((beam.xmax+beam.xmin)/2);
		beam.draw();
		
		//Update obj
		
		return {x:beam.xmin,y:anchor.yori};
	});
	createanchor(beam,beam.xmax,(beam.ymax+beam.ymin)/2,function (pos,anchor) { //7
		//var xchange = pos.x-beam.xmin;
		
		//beam.xmax = pos.x+(beam.xmax-beam.xmin);
		beam.xmax = pos.x;
		
		if (beam.xmax<beam.objcentermax && beam.objcentermax != -1) {
			beam.xmax = beam.objcentermax;
		}
		
		if (beam.xmax<beam.xmin+10) {
			beam.xmax = beam.xmin+10;
		}
		if (beam.xmax<beam.fulcrum) {
			beam.xmax = beam.fulcrum;
		}
		
		//beam.getChildren()[1].points()[0] = beam.xmin;
		//beam.getChildren()[1].points()[2] = beam.xmin;
		beam.getChildren()[1].points()[4] = beam.xmax;
		beam.getChildren()[1].points()[6] = beam.xmax;
		
		beam.anchors[1].setX(beam.xmax);
		//beam.anchors[3].setX(beam.xmin);
		beam.anchors[2].setX(beam.xmax);
		//beam.anchors[4].setX(beam.xmin);
		//center
		beam.anchors[5].setX((beam.xmax+beam.xmin)/2);
		beam.draw();
		
		//Update obj
		
		return {x:beam.xmax,y:anchor.yori};
	});
}

function beamanchorupdate (beam) {
	updateanchor(beam.anchors[0],beam.fulcrum,beam.ymax);
	updateanchor(beam.anchors[1],beam.xmax+beam.getChildren()[1].getAbsolutePosition().x,beam.ymax);
	updateanchor(beam.anchors[2],beam.xmax+beam.getChildren()[1].getAbsolutePosition().x,beam.ymin);
	updateanchor(beam.anchors[3],beam.xmin+beam.getChildren()[1].getAbsolutePosition().x,beam.ymax);
	updateanchor(beam.anchors[4],beam.xmin+beam.getChildren()[1].getAbsolutePosition().x,beam.ymin);
	updateanchor(beam.anchors[5],((beam.xmax+beam.xmin)/2)+beam.getChildren()[1].getAbsolutePosition().x,beam.ymin);
	updateanchor(beam.anchors[6],beam.xmin+beam.getChildren()[1].getAbsolutePosition().x,(beam.ymax+beam.ymin)/2);
	updateanchor(beam.anchors[7],beam.xmax+beam.getChildren()[1].getAbsolutePosition().x,(beam.ymax+beam.ymin)/2);
}

function slidescale (slide,scale) {
	var currentscale = 0.000264583/pixel2m;
	scale = scale/currentscale;
	
	var width = slide.xend-slide.xstart;
	var height = stageh-60-slide.ystart;
	var widthchange = width-(width*scale);
	var heightchange = height*scale;
	
	slide.ystart = stageh-60-heightchange;
	slide.xstart += widthchange/2;
	slide.xend -= widthchange/2;
	
	slide.getChildren()[0].points([slide.xstart,slide.ystart,slide.xstart,stageh-60,slide.xend,stageh-60]);
	
	slide.draw();
}

function beamscale (beam,scale) {
	var currentscale = 0.000264583/pixel2m;
	scale = scale/currentscale;
	
	var width = beam.xmax-beam.xmin;
	var height = beam.ymax-beam.ymin;
	var widthchange = width-(width*scale);
	var heightchange = height*scale;
	beam.xmin += widthchange/2;
	beam.xmax -= widthchange/2;
	
	var baseh = beam.getChildren()[0].getAttr("radius")+1/2*beam.getChildren()[0].getAttr("radius");
	baseh *= scale;
	
	beam.ymax = stageh-60-baseh;
	beam.ymin = beam.ymax-heightchange;
	
	beam.getChildren()[0].setY(stageh-60-baseh*1/3);
	beam.getChildren()[0].setAttr("radius",baseh*2/3);
	beam.getChildren()[1].points([beam.xmin, beam.ymin, beam.xmin, beam.ymax, beam.xmax, beam.ymax, beam.xmax, beam.ymin]);
	
	beam.draw();
	
}

function setscale (scale) {
	$.each(objects,function (index,obj) {
		switch (obj.type) {
			case "beam": beamscale (obj,scale); break;
			case "slide": slidescale (obj,scale); break;
		}
	});
	pixel2m = 0.000264583/scale;
	
	clearanchor();
	var selected = getselectedobjects();
	$.each(selected,function(index,select) {
		objcreateanchor(select);
	});
}

function arrow(fromx, fromy, tox, toy, reverse){
	if (reverse) {
		var tempfromx = fromx;
		var tempfromy = fromy;
		fromx = tox;
		fromy = toy;
		tox = tempfromx;
		toy = tempfromy;
	}
	
    var headlen = 20;   // how long you want the head of the arrow to be, you could calculate this as a fraction of the distance between the points as well.
    var angle = Math.atan2(toy-fromy,tox-fromx);

    line = new Kinetic.Line({
        points: [fromx, fromy, tox, toy, tox-headlen*Math.cos(angle-Math.PI/6),toy-headlen*Math.sin(angle-Math.PI/6),tox, toy, tox-headlen*Math.cos(angle+Math.PI/6),toy-headlen*Math.sin(angle+Math.PI/6)],
        stroke: "#00FF00"
    });
	
	return line;
}

function arrowpoint(fromx,fromy,tox,toy, reverse) {
	if (reverse) {
		var tempfromx = fromx;
		var tempfromy = fromy;
		fromx = tox;
		fromy = toy;
		tox = tempfromx;
		toy = tempfromy;
	}
	
    var headlen = 20;   // how long you want the head of the arrow to be, you could calculate this as a fraction of the distance between the points as well.
    var angle = Math.atan2(toy-fromy,tox-fromx);
	
	return [fromx, fromy, tox, toy, tox-headlen*Math.cos(angle-Math.PI/6),toy-headlen*Math.sin(angle-Math.PI/6),tox, toy, tox-headlen*Math.cos(angle+Math.PI/6),toy-headlen*Math.sin(angle+Math.PI/6)];
}

function wedge (layer,x,y) {
	var xstart = Math.min(mousestartx,x);
	var xend = Math.max(mousestartx,x);
	var ystart = mousestarty;
	layer.remove();
	layer = new Kinetic.Layer();
	var wedge = new Kinetic.Line({
		points: [xstart,ystart,xend,ystart,(xstart+xend)/2,stageh-63],
		fill: '#D8D8D8',
		stroke: '#6E6E6E',
		strokeWidth: 5,
		closed: true,
		draggable: true
	});
	layer.add(wedge);
	stage.add(layer);
	layer.type = "wedge";
	layer.xstart = xstart;
	layer.ystart = ystart;
	layer.xend = xend;
	layer.objects = [];
	layer.forces = [];
	layer.objcentermax = -1;
	layer.objcentermin = -1;
	layer.width = xend-xstart;
	layer.height = stageh-63-ystart;
	layer.w = 0.5;
	layer.weight = 50;
	wedge.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			$.each(layer.objects,function (index,obj) {
				obj.setAbsolutePosition({x:pos.x,y:0});
				obj.draw();
			});
			$.each(layer.forces,function (index,f) {
				f.setAbsolutePosition({x:pos.x,y:0});
				f.draw();
			});
			return {
				x: pos.x,
				y: this.getY()
			}
		} else {
			return {x:0,y:0}
		}
	});
	layer.on("dragmove",function() {
		selectiondrag(this);
	});

	layer.on("dragend",function() {
		selectiondragend(this);
		
		var posplus = this.getAbsolutePosition().x;
		this.xstart += posplus;
		this.xend += posplus;
		//console.log(this.getChildren()[0].points());
		
		this.setAbsolutePosition({x:0,y:0});
		this.getChildren()[0].points([this.xstart,this.ystart,this.xend,this.ystart,(this.xstart+this.xend)/2,stageh-63]);
		this.draw();
	});
	
	wedge.on("dragend",function () {
		var posplus = this.getAbsolutePosition().x;
		layer.xstart += posplus;
		layer.xend += posplus;
		
		this.setAbsolutePosition({x:0,y:0});
		this.points([layer.xstart,layer.ystart,layer.xend,layer.ystart,(layer.xstart+layer.xend)/2,stageh-63]);
		this.draw();
		
		$.each(layer.objects,function (index,obj) {
			obj.fire("dragend");
		});
		$.each(layer.forces,function (index,f) {
			f.fire("dragend");
		});
	});

	layer.on("mousedown",function(e) {
		ondragobj = this;
	});
	layer.on("mouseover",function(e) {
		this.mouseover = true;
		if (!this.selected) {
			wedge.setAttr("fill","#FAAC58");
			wedge.setAttr("stroke","#B45F04");
			layer.draw();
		}
	});
	layer.on("mouseout",function(e) {
		this.mouseover = false;
		if (!this.selected) {
			wedge.setAttr("fill","#D8D8D8");
			wedge.setAttr("stroke","#6E6E6E");
			layer.draw();
		}
	});
	layer.on("unselect",function(e) {
		if (this.mouseover) {
			wedge.setAttr("fill","#FAAC58");
			wedge.setAttr("stroke","#B45F04");
		} else {
			wedge.setAttr("fill","#D8D8D8");
			wedge.setAttr("stroke","#6E6E6E");
		}
		layer.draw();
	});
	layer.on("select",function() {
		wedge.setAttr("fill","#FF8000");
		wedge.setAttr("stroke","#B45F04");
		layer.draw();
	});
	layer.on("mousedown touchstart",function(e) {
		if (currenttool == 0) {
			currenttooloverride = true;
			currenttoolcallback = objectwedge;
			currenttoolarg = {layer:new Kinetic.Layer(),wedge:this.getLayer(),xobj:stage.getPointerPosition().x,yobj:layer.ystart};
		}
		if (currenttool == 7) {
			currenttooloverride = true;
			currenttoolcallback = forcewedge;
			currenttoolarg = {layer:new Kinetic.Layer(),wedge:this.getLayer(),xobj:stage.getPointerPosition().x,yobj:layer.ystart};
		}
	});
	
	return layer;
}

function objectwedge (arg) {
	var obj = object(new Kinetic.Layer(),arg.xobj,arg.yobj-2,arg.x,arg.y);
	arg.wedge.objects.push(obj);
	
	obj.draggable(true);
	obj.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			var x = pos.x;
			if (this.xmin+pos.x>arg.wedge.xend-((this.xmax-this.xmin)/2)) {
				x = (arg.wedge.xend-((this.xmax-this.xmin)/2))-this.xmin;
			} else if (this.xmin+pos.x<arg.wedge.xstart-((this.xmax-this.xmin)/2)) {
				x = (arg.wedge.xstart-((this.xmax-this.xmin)/2))-this.xmin;
			}
			return {
				x:x,
				y:0
			};
		} else {
			return {x:0,y:0};
		}
	});
	obj.on("dragmove",function() {
		selectiondrag(this);
	});
	//Update points (Fix ani bug) moment ...
	obj.on("dragend",function() {
		selectiondragend(this);
		
		var bounds = getobjectbounds(this,false);
		this.setAbsolutePosition({x:0,y:0});
		this.getChildren()[0].points([bounds.xmin,bounds.ymin,bounds.xmin,bounds.ymax,bounds.xmax,bounds.ymax,bounds.xmax,bounds.ymin]);
		this.draw();
		
		this.xmin = bounds.xmin;
		this.xmax = bounds.xmax;
		this.ymin = bounds.ymin;
		this.ymax = bounds.ymax;
		this.center = this.centerori = (this.xmax+this.xmin)/2;
		
		objectbeamupdatecenter(arg.wedge);
	});
	obj.instanceof = arg.wedge;
	
	objectbeamupdatecenter(arg.wedge);
	
	//updatestatus();
	return obj;
}

function forcewedge (arg) {
	var f = force(new Kinetic.Layer(),arg.xobj,arg.yobj-5,arg.x,arg.y);
	arg.wedge.forces.push(f);
	f.draggable(true);
	f.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			var x = pos.x;
			//console.log(this.xmin+pos.x);
			if (this.xstart+pos.x>arg.wedge.xend) {
				x = arg.wedge.xend-this.xstart;
			} else if (this.xend+pos.x<arg.wedge.xstart) {
				x = arg.wedge.xstart-this.xstart;
			}
			return {
				x:x,
				y:0
			};
		} else {
			return {x:0,y:0};
		}
	});
	f.on("dragmove",function() {
		selectiondrag(this);
	});
	//Update points (Fix ani bug) moment ...
	f.on("dragend",function() {
		selectiondragend(this);
		
		f.xstart = f.xstart+this.getAbsolutePosition().x;
		f.xend = f.xend+this.getAbsolutePosition().x;
		
		this.setAbsolutePosition({x:0,y:0});
		
		f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart,f.xend,f.yend,true));
		f.draw();
	});
	f.instanceof = arg.wedge;
	f.reverseable = false;
	f.reverse = true;
	f.xstartori = f.xstart;
	f.ystartori = f.ystart;
	return f;
}

function beam (layer, x,y) {
	var xmax = Math.max(mousestartx,x);
	var ymax = Math.max(mousestarty,y);
	var xmin = Math.min(mousestartx,x);
	var ymin = Math.min(mousestarty,y);
	layer.remove();
	layer = new Kinetic.Layer();
    var base = new Kinetic.RegularPolygon({
		x: xmin+((xmax-xmin)/2),
        y: (ymax+(2/3*(stageh-60-ymax))),
        sides: 3,
        radius: 2/3*(stageh-60-ymax),
        fill: '#FF8080',
        stroke: '#3030FF',
        strokeWidth: 4,
		draggable: true
	});
	var beam = new Kinetic.Line({
		points: [xmin, ymin, xmin, ymax, xmax, ymax, xmax, ymin],
		fill: '#00FFFF',
		stroke: '#00FFFF',
		strokeWidth: 1,
		closed: true,
		draggable: true
	});
	layer.add(base);
	layer.add(beam);
	stage.add(layer);
	layer.objects = [];
	layer.forces = [];
	layer.xmin = xmin;
	layer.xmax = xmax;
	layer.ymin = ymin;
	layer.ymax = ymax;
	layer.fulcrum = (xmax+xmin)/2;
	layer.objcentermax = -1;
	layer.objcentermin = -1;
	layer.centerforce = forcebeam({layer:new Kinetic.Layer(),beam:layer,xobj:(xmax+xmin)/2,yobj:shapemaxy(beam),x:(xmax+xmin)/2,y:shapemaxy(beam)+10});
	layer.centerforce.hide();
	layer.centerforce.force = 0;
	layer.angle = 0;
	base.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			var x = pos.x;
			if (x>layer.xmax) {
				x = x+(layer.xmax-x);
			} else if (x<layer.xmin) {
				x = x-(x-layer.xmin);
			}
			layer.fulcrum = x;
			/*if (layer.xmax+pos.x<=layer.fulcrum) {
				x = layer.fulcrum-layer.xmax;
			} else if (layer.xmin+pos.x>=layer.fulcrum) {
				x = layer.fulcrum-layer.xmin;
			}*/
			return {
				x: x,
				y: this.getY()
			}
		} else {
		    return { x: this.getX(), y: this.getY() };
		}
	});
	base.on("dragmove",function() {
		selectiondrag(layer);
	});
	base.on("dragend",function () {
		selectiondragend(layer);
		
		this.position(this.getAbsolutePosition());
		
		var moment = calmoment(layer);
		layer.momentr = moment.momentr;
		layer.momentl = moment.momentl;
	});
	beam.on("dragmove",function() {
		selectiondrag(layer);
	});
	beam.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			var x = pos.x;
			if (layer.xmax+pos.x<=layer.fulcrum) {
				x = layer.fulcrum-layer.xmax;
			} else if (layer.xmin+pos.x>=layer.fulcrum) {
				x = layer.fulcrum-layer.xmin;
			}
			$.each(layer.objects,function (index,obj) {
				obj.setAbsolutePosition({x:x,y:0});
				obj.draw();
			});
			$.each(layer.forces,function (index,f) {
				f.setAbsolutePosition({x:x,y:0});
				f.draw();
			});
			return {
				x: x,
				y: 0
			}
		} else {
			return {x:0,y:0}
		}
	});
	beam.on("mousedown touchstart",function(e) {
		if (currenttool == 0) {
			currenttooloverride = true;
			currenttoolcallback = objectbeam;
			currenttoolarg = {layer:new Kinetic.Layer(),beam:this.getLayer(),xobj:stage.getPointerPosition().x,yobj:shapeminy(beam)};
		}
		if (currenttool == 7) {
			currenttooloverride = true;
			currenttoolcallback = forcebeam;
			currenttoolarg = {layer:new Kinetic.Layer(),beam:this.getLayer(),xobj:stage.getPointerPosition().x,yobj:stage.getPointerPosition().y};
		}
	});
	beam.on("dragend",function() {
		selectiondragend(layer);
		
		var xmino = this.getPoints()[0];
		var xmaxo = this.getPoints()[4];
		var ymino = this.getPoints()[1];
		var ymaxo = this.getPoints()[3];
		xmin = xmino+this.getAbsolutePosition().x;
		ymin = ymino+this.getAbsolutePosition().y;
		xmax = xmin+(xmaxo-xmino);
		ymax = ymin+(ymaxo-ymino);
		
		//console.log(bounds);
		this.setAbsolutePosition({x:0,y:0});
		this.points([xmin,ymin,xmin,ymax,xmax,ymax,xmax,ymin]);
		layer.draw();
		
		layer.xmin = xmin;
		layer.xmax = xmax;
		layer.ymin = ymin;
		layer.ymax = ymax;
		var moment = calmoment(layer);
		layer.momentr = moment.momentr;
		layer.momentl = moment.momentl;
		
		//update objects
		$.each(layer.objects,function (index,obj) {
			obj.fire("dragend");
		});
		$.each(layer.forces,function (index,f) {
			f.fire("dragend");
		});
		//updatestatus();
	});
	layer.type = "beam";
	layer.id = objects.length;
	layer.weight = 0;
	layer.momentr = 0;
	layer.momentl = 0;
	layer.on("mousedown",function(e) {
		ondragobj = this;
	});
	layer.on("mouseover",function(e) {
		this.mouseover = true;
		if (!this.selected) {
			beam.setAttr("fill","#FAAC58");
			beam.setAttr("stroke","#B45F04");
			base.setAttr("fill","#FAAC58");
			base.setAttr("stroke","#B45F04");
			layer.draw();
		}
	});
	layer.on("mouseout",function(e) {
		this.mouseover = false;
		if (!this.selected) {
			beam.setAttr("fill","#00FFFF");
			beam.setAttr("stroke","#00FFFF");
			base.setAttr("fill","#FF8080");
			base.setAttr("stroke","#3030FF");
			layer.draw();
		}
	});
	layer.on("unselect",function(e) {
		if (this.mouseover) {
			beam.setAttr("fill","#FAAC58");
			beam.setAttr("stroke","#B45F04");
			base.setAttr("fill","#FAAC58");
			base.setAttr("stroke","#B45F04");
		} else {
			beam.setAttr("fill","#00FFFF");
			beam.setAttr("stroke","#00FFFF");
			base.setAttr("fill","#FF8080");
			base.setAttr("stroke","#3030FF");
		}
		layer.draw();
	});
	layer.on("select",function() {
		beam.setAttr("fill","#FF8000");
		beam.setAttr("stroke","#B45F04");
		base.setAttr("fill","#FF8000");
		base.setAttr("stroke","#B45F04");
		layer.draw();
	});
	
	return layer;
}

function forcebeam (arg) {
	if (arg.y > arg.yobj) {
		arg.yobj = shapemaxy(arg.beam.getChildren()[1]);
	} else {
		arg.yobj = shapeminy(arg.beam.getChildren()[1]);
	}
	var f = force(new Kinetic.Layer(),arg.xobj,arg.yobj-2,arg.x,arg.y);
	arg.beam.forces.push(f);
	f.draggable(true);
	f.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			var x = pos.x;
			//console.log(this.xmin+pos.x);
			if (this.xstart+pos.x>arg.beam.xmax) {
				x = arg.beam.xmax-this.xstart;
			} else if (this.xstart+pos.x<arg.beam.xmin) {
				x = arg.beam.xmin-this.xstart;
			}
			return {
				x:x,
				y:0
			};
		} else {
			return {x:0,y:0};
		}
	});
	f.on("dragmove",function() {
		selectiondrag(this);
	});
	//Update points (Fix ani bug) moment ...
	f.on("dragend",function() {
		selectiondragend(this);
		
		f.xstart = f.xstart+this.getAbsolutePosition().x;
		f.xend = f.xend+this.getAbsolutePosition().x;
		
		this.setAbsolutePosition({x:0,y:0});
		
		f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart,f.xend,f.yend,f.reverse));
		f.draw();
	});
	f.instanceof = arg.beam;
	if (arg.y > arg.yobj) {
		f.up = false;
	} else {
		f.up = true;
	}
	f.xstartori = f.xstart;
	f.ystartori = f.ystart;
	return f;
}

function forcerotate (force,angle,changeangle) {
	var h = force.d*Math.cos(angle*(Math.PI/180));
	var w = force.d*Math.sin(angle*(Math.PI/180));
	force.xend = force.xstart+w;
	force.yend = force.ystart-h;
	force.getChildren()[0].points(arrowpoint(force.xstart,force.ystart,force.xend,force.yend,force.reverse));
	force.draw();
	
	if (changeangle) {
		force.angle = Math.getAngleFromTwoPoint(force.xstart,force.ystart,force.xend,force.yend,true);
	}
}

function forcesetstart (force,x,y,temp) {
	if (temp) {
		var tempx = force.xstart;
		var tempy = force.ystart;
	}
	force.xstart = x;
	force.ystart = y;
	forcerotate(force,force.angle);
	if (temp) {
		force.xstart = tempx;
		force.ystart = tempy;
	}
}

function force (layer,x1,y1,x2,y2) {
	layer.remove();
	layer = new Kinetic.Layer();
	var force = arrow(x1,y1,x2,y2);
	force.strokeWidth(4);
	layer.add(force);
	stage.add(layer);
	layer.force = 0.5;
	layer.type = "force";
	layer.angle = Math.getAngleFromTwoPoint(x1,y1,x2,y2,true);
	layer.xstart = x1;layer.ystart = y1;layer.xend = x2;layer.yend = y2;
	layer.d = Math.linear.getPointDistance(x1,y1,x2,y2,true);
	layer.reverse = false;
	layer.reverseable = true;
	layer.lockangle = false;
	layer.on("mousedown",function(e) {
		ondragobj = this;
	});
	layer.on("mouseover",function(e) {
		this.mouseover = true;
		if (!this.selected) {
			force.setAttr("stroke","#FAAC58");
			layer.draw();
		}
	});
	layer.on("mouseout",function(e) {
		this.mouseover = false;
		if (!this.selected) {
			force.setAttr("stroke","#00FF00");
			layer.draw();
		}
	});
	layer.on("unselect",function(e) {
		if (this.mouseover) {
			force.setAttr("stroke","#FAAC58");
		} else {
			force.setAttr("stroke","#00FF00");
		}
		layer.draw();
	});
	layer.on("select",function() {
		force.setAttr("stroke","#FF8000");
		layer.draw();
	})
	return layer;
}

function rope (layer,x1,y1,x2,y2) {
	layer.remove();
	layer = new Kinetic.Layer();
	var rope = new Kinetic.Line({
		points: [x1,y1,x2,y2],
		stroke: '#FAFAFA',
		strokeWidth: 3
	});;
	rope.strokeWidth(4);
	layer.add(rope);
	stage.add(layer);
	layer.type = "rope";
	layer.xstart = x1;
	layer.xend = x2;
	layer.d = Math.linear.getPointDistance(x1,y1,x2,y2,true);
	layer.locked = false;
	layer.ystart = y1;
	layer.yend = y2;
	layer.objects = [];
	layer.forces = [];
	layer.up = (y1 > y2);
	layer.force = 0.1;
	layer.weight = 0;
	layer.on("mousedown",function(e) {
		ondragobj = this;
	});
	layer.on("mouseover",function(e) {
		this.mouseover = true;
		if (!this.selected) {
			rope.setAttr("stroke","#FAAC58");
			layer.draw();
		}
	});
	layer.on("mouseout",function(e) {
		this.mouseover = false;
		if (!this.selected) {
			rope.setAttr("stroke","#FAFAFA");
			layer.draw();
		}
	});
	layer.on("unselect",function(e) {
		if (this.mouseover) {
			rope.setAttr("stroke","#FAAC58");
		} else {
			rope.setAttr("stroke","#FAFAFA");
		}
		layer.draw();
	});
	layer.on("select",function() {
		rope.setAttr("stroke","#FF8000");
		layer.draw();
	})
	layer.on("mousedown touchstart",function(e) {
		if (currenttool == 0 && !layer.locked && !layer.up) {
			currenttooloverride = true;
			currenttoolcallback = objectrope;
			currenttoolarg = {layer:new Kinetic.Layer(),rope:layer,xobj:layer.xend,yobj:layer.yend};
		}
		if (currenttool == 7 && !layer.locked) {
			currenttooloverride = true;
			currenttoolcallback = forcerope;
			currenttoolarg = {layer:new Kinetic.Layer(),rope:layer,xobj:layer.xend,yobj:layer.yend};
		}
	});
	return layer;
}

function objectrope (arg) {
	if ((arg.rope.up && arg.yobj > arg.y) || (!arg.rope.up && arg.yobj < arg.y)) {
		var width = Math.abs(arg.x-arg.xobj);
		var obj = object(new Kinetic.Layer(),arg.xobj-width,arg.yobj,arg.xobj+width,arg.y);
		arg.rope.objects.push(obj);
		obj.instanceof = arg.rope;
		return obj;
	}
}

function forcerope (arg) {
	if ((arg.rope.up && arg.yobj > arg.y) || (!arg.rope.up && arg.yobj < arg.y)) {
		var f = force(new Kinetic.Layer(),arg.xobj,arg.yobj,arg.xobj,arg.y);
		arg.rope.forces.push(f);
		f.lockangle = true;
		f.instanceof = arg.rope;
		return f;
	}
}

function pulleyrope (pulley,xobj,yobj,y,locked) {
	var ro = rope(new Kinetic.Layer(),xobj,yobj,xobj,y);
	ro.locked = locked;
	ro.instanceof = pulley;
	
	setTimeout(function () {
		ro.anchors = [];
		ro.selected = false;
		ro.ondrag = false;
		ro.ondragblocker = true;
		ro.id = objects.length;
		ro.active = true;
		objects.push(ro);
	},10);
	return ro;
}

function setpulleytype (pulley,type) {
	pulley.pulleytype = type;
	switch (type) {
		case 0:
		    deleteobject(pulley.leftrope); pulley.leftrope.remove();
		    deleteobject(pulley.rightrope); pulley.rightrope.remove();
		    deleteobject(pulley.middlerope); pulley.middlerope.remove();
		    pulley.center = { x: 75, y: 100 };
		    pulley.getChildren()[0].setX(75); pulley.getChildren()[0].setY(100);
			pulley.leftrope = pulleyrope(pulley,pulley.center.x-pulley.r,pulley.center.y,pulley.center.y+100,false);
			pulley.rightrope = pulleyrope(pulley,pulley.center.x+pulley.r,pulley.center.y,pulley.center.y+100,false);
			pulley.middlerope = pulleyrope(pulley, pulley.center.x, pulley.center.y - pulley.r, 38, true);
			var e = forcerope({ layer: new Kinetic.Layer(), rope: pulley.rightrope, xobj: pulley.rightrope.xend, yobj: pulley.rightrope.yend, x: pulley.rightrope.xend, y: pulley.rightrope.yend + 50 });
			var w = objectrope({ layer: new Kinetic.Layer(), rope: pulley.leftrope, xobj: pulley.leftrope.xend, yobj: pulley.leftrope.yend, x: pulley.leftrope.xend + 20, y: pulley.leftrope.yend + 50 });
			objects.push(w);
			objects.push(e);
			break;
		case 1:
		    deleteobject(pulley.leftrope); pulley.leftrope.remove();
		    deleteobject(pulley.rightrope); pulley.rightrope.remove();
		    deleteobject(pulley.middlerope); pulley.middlerope.remove();
			pulley.leftrope = pulleyrope(pulley,pulley.center.x-pulley.r,pulley.center.y,pulley.center.y-100,false);
			pulley.rightrope = pulleyrope(pulley,pulley.center.x+pulley.r,pulley.center.y,pulley.center.y-100,false);
			pulley.middlerope = pulleyrope(pulley,pulley.center.x,pulley.center.y+pulley.r,stageh-58,true);
			break;
		case 2:
		    deleteobject(pulley.leftrope); pulley.leftrope.remove();
		    deleteobject(pulley.rightrope); pulley.rightrope.remove();
		    deleteobject(pulley.middlerope); pulley.middlerope.remove();
		    pulley.center = { x: 75, y: 200 };
		    pulley.getChildren()[0].setX(75); pulley.getChildren()[0].setY(200);
			pulley.leftrope = pulleyrope(pulley,pulley.center.x-pulley.r,pulley.center.y,38,true);
			pulley.rightrope = pulleyrope(pulley,pulley.center.x+pulley.r,pulley.center.y,pulley.center.y-100,false);
			pulley.middlerope = pulleyrope(pulley, pulley.center.x, pulley.center.y + pulley.r, pulley.center.y + pulley.r + 100, false);
			var e = forcerope({ layer: new Kinetic.Layer(), rope: pulley.rightrope, xobj: pulley.rightrope.xend, yobj: pulley.rightrope.yend, x: pulley.rightrope.xend, y: pulley.rightrope.yend - 50 });
			var w = objectrope({ layer: new Kinetic.Layer(), rope: pulley.middlerope, xobj: pulley.middlerope.xend, yobj: pulley.middlerope.yend, x: pulley.middlerope.xend + 20, y: pulley.middlerope.yend + 50 });
			objects.push(w);
			objects.push(e);
			break;
		case 3:
		    deleteobject(pulley.leftrope); pulley.leftrope.remove();
		    deleteobject(pulley.rightrope); pulley.rightrope.remove();
		    deleteobject(pulley.middlerope); pulley.middlerope.remove();
		    pulley.center = { x: 75, y: 200 };
		    pulley.getChildren()[0].setX(75); pulley.getChildren()[0].setY(200);
			pulley.leftrope = pulleyrope(pulley,pulley.center.x-pulley.r,pulley.center.y,pulley.center.y-100,false);
			pulley.rightrope = pulleyrope(pulley,pulley.center.x+pulley.r,pulley.center.y,38,true);
			pulley.middlerope = pulleyrope(pulley, pulley.center.x, pulley.center.y + pulley.r, pulley.center.y + pulley.r + 100, false);
			var e = forcerope({ layer: new Kinetic.Layer(), rope: pulley.leftrope, xobj: pulley.leftrope.xend, yobj: pulley.leftrope.yend, x: pulley.leftrope.xend, y: pulley.leftrope.yend - 50 });
			var w = objectrope({ layer: new Kinetic.Layer(), rope: pulley.middlerope, xobj: pulley.middlerope.xend, yobj: pulley.middlerope.yend, x: pulley.middlerope.xend + 20, y: pulley.middlerope.yend + 50 });
			objects.push(w);
			objects.push(e);
			break;
		case 4:
		    deleteobject(pulley.leftrope); pulley.leftrope.remove();
		    deleteobject(pulley.rightrope); pulley.rightrope.remove();
		    deleteobject(pulley.middlerope); pulley.middlerope.remove();
			pulley.leftrope = pulleyrope(pulley,pulley.center.x-pulley.r,pulley.center.y,stageh-58,true);
			pulley.rightrope = pulleyrope(pulley,pulley.center.x+pulley.r,pulley.center.y,pulley.center.y+100,false);
			pulley.middlerope = pulleyrope(pulley,pulley.center.x,pulley.center.y-pulley.r,pulley.center.y-pulley.r-100,false);
			break;
		case 5:
		    deleteobject(pulley.leftrope); pulley.leftrope.remove();
		    deleteobject(pulley.rightrope); pulley.rightrope.remove();
		    deleteobject(pulley.middlerope); pulley.middlerope.remove();
			pulley.leftrope = pulleyrope(pulley,pulley.center.x-pulley.r,pulley.center.y,pulley.center.y+100,false);
			pulley.rightrope = pulleyrope(pulley,pulley.center.x+pulley.r,pulley.center.y,stageh-58,true);
			pulley.middlerope = pulleyrope(pulley,pulley.center.x,pulley.center.y-pulley.r,pulley.center.y-pulley.r-100,false);
			break;
	}

	objects[5].force = 1;
	toggleselection(pulley);
	toggleselection(pulley);
	clearanchor();
}

function getropeforce (rope) {
	
}

function setropepoint (rope,points) {
	rope.getChildren()[0].points(points);
	rope.xstart = points[0];
	rope.ystart = points[1];
	rope.xend = points[2];
	rope.yend = points[3];
}

function pulleyupdaterope (pulley) {
	
	switch (pulley.pulleytype) {
		case 0:
			setropepoint(pulley.leftrope,[pulley.center.x-pulley.r,pulley.center.y,pulley.center.x-pulley.r,pulley.center.y+pulley.leftrope.d]);
			setropepoint(pulley.rightrope,[pulley.center.x+pulley.r,pulley.center.y,pulley.center.x+pulley.r,pulley.center.y+pulley.rightrope.d]);
			setropepoint(pulley.middlerope,[pulley.center.x,pulley.center.y-pulley.r,pulley.center.x,38]);
			pulley.leftrope.draw();
			pulley.rightrope.draw();
			pulley.middlerope.draw();
			break;
		case 1:
			setropepoint(pulley.leftrope,[pulley.center.x-pulley.r,pulley.center.y,pulley.center.x-pulley.r,pulley.center.y-pulley.leftrope.d]);
			setropepoint(pulley.rightrope,[pulley.center.x+pulley.r,pulley.center.y,pulley.center.x+pulley.r,pulley.center.y-pulley.rightrope.d]);
			setropepoint(pulley.middlerope,[pulley.center.x,pulley.center.y+pulley.r,pulley.center.x,stageh-58]);
			pulley.leftrope.draw();
			pulley.rightrope.draw();
			pulley.middlerope.draw();
			break;
		case 2:
			setropepoint(pulley.leftrope,[pulley.center.x-pulley.r,pulley.center.y,pulley.center.x-pulley.r,38]);
			setropepoint(pulley.rightrope,[pulley.center.x+pulley.r,pulley.center.y,pulley.center.x+pulley.r,pulley.center.y-pulley.rightrope.d]);
			setropepoint(pulley.middlerope,[pulley.center.x,pulley.center.y+pulley.r,pulley.center.x,pulley.center.y+pulley.r+pulley.middlerope.d]);
			pulley.leftrope.draw();
			pulley.rightrope.draw();
			pulley.middlerope.draw();
			break;
		case 3:
			setropepoint(pulley.leftrope,[pulley.center.x-pulley.r,pulley.center.y,pulley.center.x-pulley.r,pulley.center.y-pulley.leftrope.d]);
			setropepoint(pulley.rightrope,[pulley.center.x+pulley.r,pulley.center.y,pulley.center.x+pulley.r,38]);
			setropepoint(pulley.middlerope,[pulley.center.x,pulley.center.y+pulley.r,pulley.center.x,pulley.center.y+pulley.r+pulley.middlerope.d]);
			pulley.leftrope.draw();
			pulley.rightrope.draw();
			pulley.middlerope.draw();
			break;
		case 4:
			setropepoint(pulley.leftrope,[pulley.center.x-pulley.r,pulley.center.y,pulley.center.x-pulley.r,stageh-58]);
			setropepoint(pulley.rightrope,[pulley.center.x+pulley.r,pulley.center.y,pulley.center.x+pulley.r,pulley.center.y+pulley.rightrope.d]);
			setropepoint(pulley.middlerope,[pulley.center.x,pulley.center.y-pulley.r,pulley.center.x,pulley.center.y-pulley.r-pulley.middlerope.d]);
			pulley.leftrope.draw();
			pulley.rightrope.draw();
			pulley.middlerope.draw();
			break;
		case 5:
			setropepoint(pulley.leftrope,[pulley.center.x-pulley.r,pulley.center.y,pulley.center.x-pulley.r,pulley.center.y+pulley.leftrope.d]);
			setropepoint(pulley.rightrope,[pulley.center.x+pulley.r,pulley.center.y,pulley.center.x+pulley.r,stageh-58]);
			setropepoint(pulley.middlerope,[pulley.center.x,pulley.center.y-pulley.r,pulley.center.x,pulley.center.y-pulley.r-pulley.middlerope.d]);
			pulley.leftrope.draw();
			pulley.rightrope.draw();
			pulley.middlerope.draw();
			break;
	}
	$.each(pulley.leftrope.objects.concat(pulley.rightrope.objects).concat(pulley.middlerope.objects),function(index,obj) {
		obj.xmin = obj.instanceof.xend-obj.width/2;
		obj.ymin = obj.instanceof.yend;
		obj.xmax = obj.instanceof.xend+obj.width/2;
		obj.ymax = obj.instanceof.yend+obj.height;
		obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
		setTimeout(function () {
			obj.draggable(false);
		},10);
		obj.draw();
	});	
	$.each(pulley.leftrope.forces.concat(pulley.rightrope.forces).concat(pulley.middlerope.forces),function(index,f) {
		if (f.instanceof.up) {
			f.xstart = f.instanceof.xend;
			f.ystart = f.instanceof.yend;
			f.xend = f.instanceof.xend;
			f.yend = f.instanceof.yend-f.d;
		} else {
			f.xstart = f.instanceof.xend;
			f.ystart = f.instanceof.yend;
			f.xend = f.instanceof.xend;
			f.yend = f.instanceof.yend+f.d;
		}
		f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart,f.xend,f.yend,f.reverse));
		setTimeout(function () {
			f.draggable(false);
		},10);
		f.draw();
	});
}

function wheelrope (wheel,xobj,yobj,y,locked) {
	var ro = rope(new Kinetic.Layer(),xobj,yobj,xobj,y);
	ro.locked = locked;
	ro.instanceof = wheel;
	
	setTimeout(function () {
		ro.anchors = [];
		ro.selected = false;
		ro.ondrag = false;
		ro.ondragblocker = true;
		ro.id = objects.length;
		ro.active = true;
		objects.push(ro);
	},10);
	return ro;
}

function wheelupdaterope (wheel) {
	var abpos = wheel.getAbsolutePosition();

	var center = {
		x: wheel.center.x+abpos.x,
		y: wheel.center.y+abpos.y
	};
	
	setropepoint(wheel.outerrope,[center.x+wheel.r,center.y,center.x+wheel.r,center.y+wheel.outerrope.d]);
	setropepoint(wheel.innerrope,[center.x-wheel.rinner,center.y,center.x-wheel.rinner,center.y+wheel.innerrope.d]);
	wheel.outerrope.draw();
	wheel.innerrope.draw();
	
	$.each(wheel.outerrope.objects.concat(wheel.innerrope.objects),function(index,obj) {
		obj.xmin = obj.instanceof.xend-obj.width/2;
		obj.ymin = obj.instanceof.yend;
		obj.xmax = obj.instanceof.xend+obj.width/2;
		obj.ymax = obj.instanceof.yend+obj.height;
		obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
		setTimeout(function () {
			obj.draggable(false);
		},10);
		obj.draw();
	});	
	$.each(wheel.outerrope.forces.concat(wheel.innerrope.forces),function(index,f) {
		if (f.instanceof.up) {
			f.xstart = f.instanceof.xend;
			f.ystart = f.instanceof.yend;
			f.xend = f.instanceof.xend;
			f.yend = f.instanceof.yend-f.d;
		} else {
			f.xstart = f.instanceof.xend;
			f.ystart = f.instanceof.yend;
			f.xend = f.instanceof.xend;
			f.yend = f.instanceof.yend+f.d;
		}
		f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart,f.xend,f.yend,f.reverse));
		setTimeout(function () {
			f.draggable(false);
		},10);
		f.draw();
	});
}

function wheel (layer,x,y) {
	layer.remove();
	layer = new Kinetic.Layer();
	var r = Math.linear.getPointDistance(mousestartx,mousestarty,x,y,true);
	var outer = new Kinetic.Circle({
		x: mousestartx,
		y: mousestarty,
		radius: r,
		fill: '#ECE0F8',
		stroke: '#BE81F7',
		strokeWidth: 4
	});
	var inner = new Kinetic.Circle({
		x: mousestartx,
		y: mousestarty,
		radius: r/2,
		fill: '#ECE0F8',
		stroke: '#BE81F7',
		strokeWidth: 4
	});
	layer.draggable(true);
	layer.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			wheelupdaterope(layer);
			return {
				x: pos.x,
				y: pos.y
			};
		} else {
			return {x:0,y:0};
		}
	});
	/*outer.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			layer.center = {x:pos.x,y:pos.y};
			pulleyupdaterope(layer);
			return {
				x: pos.x,
				y: pos.y
			};
		} else {
			return {x:layer.center.x,y:layer.center.y};
		}
	});*/
	layer.add(outer);
	layer.add(inner);
	stage.add(layer);
	
	this.mouseover = false;
	layer.center = {x:mousestartx,y:mousestarty};
	layer.rope = [];
	//layer.pulleytype = 0; //0 = normalup 1 = normaldown 2 = moveupleft 3 = moveupright 4 = movedownleft 5 = movedownright
	layer.r = r;
	layer.rinner = r/2;
	/*layer.leftrope = pulleyrope(layer,layer.center.x-layer.r,layer.center.y,layer.center.y+100,false);
	layer.rightrope = pulleyrope(layer,layer.center.x+layer.r,layer.center.y,layer.center.y+100,false);
	layer.middlerope = pulleyrope(layer,layer.center.x,layer.center.y-layer.r,38,true);*/
	layer.outerrope = wheelrope(layer,layer.center.x+layer.r,layer.center.y,layer.center.y+100,false);
	layer.innerrope = wheelrope(layer,layer.center.x-layer.r/2,layer.center.y,layer.center.y+100,false);
	layer.type = "wheel";
	layer.weight = 1;
	
	layer.on("dragmove",function() {
		selectiondrag(this);
	});

	layer.on("dragend",function() {
		selectiondragend(outer);
		selectiondragend(inner);
		
		var abpos = layer.getAbsolutePosition();
		
		layer.center = {
			x: layer.center.x+abpos.x,
			y: layer.center.y+abpos.y
		};
		
		layer.getChildren()[0].setX(layer.center.x);
		layer.getChildren()[0].setY(layer.center.y);
		layer.getChildren()[1].setX(layer.center.x);
		layer.getChildren()[1].setY(layer.center.y);
		layer.setAbsolutePosition({x:0,y:0});
		
		layer.draw();
	});

	layer.on("mousedown",function(e) {
		ondragobj = this;
	});
	layer.on("mouseover",function(e) {
		this.mouseover = true;
		if (!this.selected) {
			outer.setAttr("fill","#FAAC58");
			outer.setAttr("stroke","#B45F04");
			inner.setAttr("fill","#FAAC58");
			inner.setAttr("stroke","#B45F04");
			layer.draw();
		}
	});
	layer.on("mouseout",function(e) {
		this.mouseover = false;
		if (!this.selected) {
			outer.setAttr("fill","#ECE0F8");
			outer.setAttr("stroke","#BE81F7");
			inner.setAttr("fill","#ECE0F8");
			inner.setAttr("stroke","#BE81F7");
			layer.draw();
		}
	});
	layer.on("unselect",function(e) {
		if (this.mouseover) {
			outer.setAttr("fill","#FAAC58");
			outer.setAttr("stroke","#B45F04");
			inner.setAttr("fill","#FAAC58");
			inner.setAttr("stroke","#B45F04");
		} else {
			outer.setAttr("fill","#ECE0F8");
			outer.setAttr("stroke","#BE81F7");
			inner.setAttr("fill","#ECE0F8");
			inner.setAttr("stroke","#BE81F7");
		}
		layer.draw();
	});
	layer.on("select",function() {
		outer.setAttr("fill","#FF8000");
		outer.setAttr("stroke","#B45F04");
		inner.setAttr("fill","#FF8000");
		inner.setAttr("stroke","#B45F04");
		layer.draw();
	});
	layer.on("mousedown touchstart",function(e) {
		/*if (currenttool == 8) {
			var xobj = layer.center.x;
			if (stage.getPointerPosition().x > layer.center.x) {
				xobj += r;
			} else {
				xobj -= r;
			}
			currenttooloverride = true;
			currenttoolcallback = pulleyrope;
			currenttoolarg = {layer:new Kinetic.Layer(),pulley:layer,xobj:xobj,yobj:layer.center.y};
		}*/
	});
	
	return layer;
}

function updatescrew(screw) {
    screw.getChildren()[0].points([screw.xmin, screw.y, screw.xmin, stageh - 60, screw.xmax, stageh - 60, screw.xmax, screw.y]);
    screw.hand.points([screw.xmax + 7, stageh - 83, screw.xmax + screw.handd + 7, stageh - 83]);
    screw.pipe.points([screw.xmin - 5, screw.y, screw.xmin - 5, stageh - 80, screw.xmax + 5, stageh - 80, screw.xmax + 5, screw.y]);
    screw.objbase.points([screw.xmin - 20, screw.y, screw.xmin - 20, screw.y - 7, screw.xmax + 20, screw.y - 7, screw.xmax + 20, screw.y]);

    /*$.each(screw.screwline, function (index, line) {
        line.remove();
    })
    screw.draw();

    screw.screwline = [];*/
    for (i = 0; i < (stageh - 60 - 40) / screw.h; i++) {
        if (((stageh - 70) - (i * screw.h + screw.h / 2)) < screw.y) {
            var linexmax = screw.xmin + 2 * (((stageh - 60 - i * screw.h) - screw.y) * screw.width) / screw.h;
            var lineymax = screw.y;
        } else {
            var linexmax = screw.xmax;
            var lineymax = (stageh - 60) - (i * screw.h + screw.h / 2);
        }
        //console.log(i+" "+screw.screwline[i]);
        if (screw.screwline[i]) {
            screw.screwline[i].show();
            screw.screwline[i].points([screw.xmin, (stageh - 60) - (i * screw.h), linexmax, lineymax]);
        } else {
            //console.log(linexmax);
            var line = new Kinetic.Line({
                points: [screw.xmin, (stageh - 60) - (i * screw.h), linexmax, lineymax],
                stroke: '#FA5858',
                strokeWidth: 2,
                closed: false
            });
            screw.add(line);
            screw.screwline.push(line);
        }
    }
    //console.log(Math.ceil(screw.height / screw.h));
    //console.log(screw.screwline.length);
    for (i = screw.height / screw.h; i < screw.screwline.length; i++) {
        try {
            screw.screwline[Math.ceil(i)].hide();
        } catch (e) {}
    }
    /*for (i = screw.height / screw.h; i < screw.screwline.length-1; i++) {
        screw.screwline.pop();
    }*/

    $.each(screw.objects, function (index, obj) {
        obj.ymin = screw.y - 10 - obj.height;
        obj.ymax = screw.y - 10;
        obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
        obj.draw();
    });
    
    screw.objbase.draw();
    screw.pipe.draw();
    screw.pipe.moveToTop();
    screw.hand.moveToTop();

    screw.draw();
}

function screwani(screw,distance) {
    var angle = (360 / screw.h * distance) % 360;

    //hand
    var hand1angle = screw.handd / 90;
    var screwup = screw.h / 360 * angle;
    if (angle <= 90) {
        var handend = screw.xmax + 7 + screw.handd - (screw.width / 2) - angle * hand1angle;
        screw.hand.points([screw.xmax + 7 - (screw.width * angle / 90), stageh - 83 - distance, handend, stageh - 83 - distance]);
    } else if (angle > 90 && angle <= 180) {
        var handend = screw.xmin - 7 - screw.handd + (screw.width / 2) + ((180 - angle) * hand1angle);
        screw.hand.points([screw.xmin - 7 + (screw.width * (180 - angle) / 90), stageh - 83 - distance, handend, stageh - 83 - distance]);
    } else if (angle > 180 && angle <= 270) {
        var handend = screw.xmin - 7 - screw.handd + (screw.width / 2) + ((angle - 180) * hand1angle);
        screw.hand.points([screw.xmin - 7, stageh - 83 - distance, (handend < screw.xmin - 7) ? handend : screw.xmin - 7, stageh - 83 - distance]);
    } else {
        var handend = screw.xmax + 7 + screw.handd - (screw.width / 2) - ((360 - angle) * hand1angle);
        screw.hand.points([screw.xmax + 7, stageh - 83 - distance, (handend > screw.xmax + 7) ? handend : screw.xmax + 7, stageh - 83 - distance]);
	}
	
	//screw
    screw.pipe.points([screw.xmin - 5, screw.y - distance, screw.xmin - 5, stageh - 80 - distance, screw.xmax + 5, stageh - 80 - distance, screw.xmax + 5, screw.y - distance]);
    /*var newy = screw.y - distance;
    var newheight = stageh - 70 - newy;

    //console.log(newheight);
    for (i = 0; i < (newheight - screwup) / screw.h; i++) {
        try {
            screw.screwline[i].show();
            if (((stageh - 70) - (i * screw.h + screw.h / 2 + screwup)) < newy) {
                var linexmax = screw.xmin + 2 * (((stageh - 70 - i * screw.h - screwup) - newy) * screw.width) / screw.h;
                var lineymax = newy;
            } else {
                var linexmax = screw.xmax;
                var lineymax = ((stageh - 70) - (i * screw.h + screw.h / 2)) - screwup;
            }
            screw.screwline[i].points([screw.xmin, (stageh - 70) - (i * screw.h) - screwup, linexmax, lineymax]);
        } catch (e) {
            console.log(i);
            var line = new Kinetic.Line({
                points: [screw.xmin, (stageh - 70) - (i * screw.h) - screwup, linexmax, lineymax],
                stroke: '#FA5858',
                strokeWidth: 4,
                closed: false
            });
            screw.add(line);
            screw.screwline.push(line);
        }
	}

	for (i = (screw.height - screwup) / screw.h; i < (screw.height / screw.h)-1; i++) {
	    screw.screwline[Math.ceil(i)].hide();
	}*/

    //objects
    $.each(screw.objects, function (index, obj) {
        obj.getChildren()[0].points([obj.xmin, obj.ymin - distance, obj.xmin, obj.ymax - distance, obj.xmax, obj.ymax - distance, obj.xmax, obj.ymin - distance]);
        obj.draw();
    });

    screw.objbase.points([screw.xmin - 20, screw.y - distance, screw.xmin - 20, screw.y - 7 - distance, screw.xmax + 20, screw.y - 7 - distance, screw.xmax + 20, screw.y - distance]);
    screw.objbase.draw();

    screw.draw();
}

function objectscrew(arg) {
    var obj = object(new Kinetic.Layer(), arg.xobj, arg.yobj - 2, arg.x, arg.y);
    arg.screw.objects.push(obj);
    obj.center = obj.centerori = (obj.xmax + obj.xmin) / 2;
    obj.draggable(true);
    obj.dragBoundFunc(function (pos) {
        if (currenttool == -1) {
            var x = pos.x;
            if (this.xmin + pos.x > arg.screw.xmax - ((this.xmax - this.xmin) / 2)) {
                x = (arg.screw.xmax - ((this.xmax - this.xmin) / 2)) - this.xmin;
            } else if (this.xmin + pos.x < arg.screw.xmin - ((this.xmax - this.xmin) / 2)) {
                x = (arg.screw.xmin - ((this.xmax - this.xmin) / 2)) - this.xmin;
            }
            return {
                x: x,
                y: 0
            };
        } else {
            return { x: 0, y: 0 };
        }
    });
    obj.on("dragmove", function () {
        selectiondrag(this);
    });
    //Update points (Fix ani bug) moment ...
    obj.on("dragend", function () {
        selectiondragend(this);

        var bounds = getobjectbounds(this, false);
        this.setAbsolutePosition({ x: 0, y: 0 });
        this.getChildren()[0].points([bounds.xmin, bounds.ymin, bounds.xmin, bounds.ymax, bounds.xmax, bounds.ymax, bounds.xmax, bounds.ymin]);
        this.draw();

        this.xmin = bounds.xmin;
        this.xmax = bounds.xmax;
        this.ymin = bounds.ymin;
        this.ymax = bounds.ymax;
        this.center = this.centerori = (this.xmax + this.xmin) / 2;

        objectbeamupdatecenter(arg.screw);
    });
    obj.instanceof = arg.screw;

    objectbeamupdatecenter(arg.screw);

    //updatestatus();
    return obj;
}

function screw (layer, x, y) {
    layer.remove();
    layer = new Kinetic.Layer();

    var xmax = Math.max(mousestartx, x);
    var xmin = Math.min(mousestartx, x);
    var y = Math.min(mousestarty, y);
    var r = Math.linear.getPointDistance(mousestartx, mousestarty, x, y, true) / 2;
    var base = new Kinetic.Line({
        points: [xmin, y, xmin, stageh-60, xmax, stageh-60, xmax, y],
        fill: '#F6CECE',
        stroke: '#FA5858',
        strokeWidth: 4,
        closed: true
    });
	layer.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
		    var x = pos.x;
		    $.each(layer.objects, function (index, obj) {
		        obj.setAbsolutePosition({ x: x, y: 0 });
		        obj.draw();
		    });
			return {
				x: x,
				y: this.getY()
			}
		} else {
			return {x:0,y:0}
		}
	});
	
	layer.xmax = xmax;
	layer.xmin = xmin;
	layer.y = y;
	layer.height = stageh - 70 - y;
	layer.width = layer.xmax - layer.xmin;
	layer.h = 5;
	layer.center = (xmax + xmin) / 2;
	layer.objects = [];
	layer.type = "screw";
	layer.e = 0.1;

	layer.objcentermin = -1;
	layer.objcentermax = -1;
	
	layer.add(base);
	
	layer.screwline = [];
	/*for (i = 0; i < (stageh - 70 - 40) / layer.h; i++) {
	    if (((stageh - 70) - (i * layer.h + layer.h / 2)) < layer.y) {
	        var linexmax = layer.xmin + 2 * (((stageh - 70 - i * layer.h) - layer.y) * layer.width) / layer.h;
	        var lineymax = layer.y;
	    } else {
	        var linexmax = layer.xmax;
	        var lineymax = (stageh - 70) - (i * layer.h + layer.h / 2);
	    }
		var line = new Kinetic.Line({
		    points: [layer.xmin, (stageh-70)-(i*layer.h), linexmax, lineymax],
		    stroke: '#FA5858',
			strokeWidth: 4,
			closed: false
    	});
		layer.add(line);
		layer.screwline.push(line);
	}*/

	layer.pipe = new Kinetic.Line({
	    points: [xmin-5, y, xmin-5, stageh - 80, xmax+5, stageh - 80, xmax+5, y],
	    fill: '#00BFFF',
	    stroke: '#00BFFF',
	    strokeWidth: 4,
	    closed: true
	});

	layer.objbase = new Kinetic.Line({
	    points: [xmin - 20, y, xmin - 20, y - 7, xmax + 20, y - 7, xmax + 20, y],
	    fill: '#00BFFF',
	    stroke: '#00BFFF',
	    strokeWidth: 4,
	    closed: true
	});

	layer.add(layer.pipe);
	layer.add(layer.objbase);
	
	//layer.handend = xmax+100;
	layer.handd = 100;
	layer.hand = new Kinetic.Line({
		points: [layer.xmax, stageh-83, layer.xmax+layer.handd, stageh-83],
		stroke: '#045FB4',
		strokeWidth: 10,
		closed: false
	});
	layer.add(layer.hand);
	//console.log([xmax, stageh-60, layer.xmax+layer.handd, stageh-60]);

	stage.add(layer);
	layer.draggable(true);

	updatescrew(layer);

	base.on("mousedown touchstart", function (e) {
	    if (currenttool == 0) {
	        currenttooloverride = true;
	        currenttoolcallback = objectscrew;
	        currenttoolarg = { layer: new Kinetic.Layer(), screw: this.getLayer(), xobj: stage.getPointerPosition().x, yobj: shapeminy(base) };
	    }
	});

	layer.on("dragmove", function () {
	    selectiondrag(this);
	});

	layer.on("dragend", function () {
	    //selectiondragend(base);
		var abspos = layer.getAbsolutePosition();
		layer.setAbsolutePosition({x:0,y:0});
		//console.log(abspos);
		
		layer.xmax += abspos.x;
		layer.xmin += abspos.x;
		layer.center += abspos.x;
		updatescrew(layer);

		$.each(layer.objects, function (index, obj) {
		    obj.fire("dragend");
		});
	});

	layer.on("mousedown", function (e) {
	    ondragobj = this;
	});
	layer.on("mouseover", function (e) {
	    this.mouseover = true;
	    if (!this.selected) {
	        base.setAttr("fill", "#FAAC58");
	        base.setAttr("stroke", "#B45F04");
	        layer.hand.setAttr("fill", "#FAAC58");
	        layer.hand.setAttr("stroke", "#B45F04");
	        $.each(layer.screwline, function (index, line) {
	            line.setAttr("fill", "#FAAC58");
	            line.setAttr("stroke", "#B45F04");
	        });
	        layer.draw();
	    }
	});
	layer.on("mouseout", function (e) {
	    this.mouseover = false;
	    if (!this.selected) {
	        base.setAttr("fill", "#F6CECE");
	        base.setAttr("stroke", "#FA5858");
	        layer.hand.setAttr("fill", "#F6CECE");
	        layer.hand.setAttr("stroke", "#045FB4");
	        $.each(layer.screwline, function (index, line) {
	            line.setAttr("fill", "#F6CECE");
	            line.setAttr("stroke", "#FA5858");
	        });
	        layer.draw();
	    }
	});
	layer.on("unselect", function (e) {
	    if (this.mouseover) {
	        base.setAttr("fill", "#FAAC58");
	        base.setAttr("stroke", "#B45F04");
	        layer.hand.setAttr("fill", "#FAAC58");
	        layer.hand.setAttr("stroke", "#B45F04");
	        $.each(layer.screwline, function (index, line) {
	            line.setAttr("fill", "#FAAC58");
	            line.setAttr("stroke", "#B45F04");
	        });
	    } else {
	        base.setAttr("fill", "#F6CECE");
	        base.setAttr("stroke", "#FA5858");
	        layer.hand.setAttr("fill", "#F6CECE");
	        layer.hand.setAttr("stroke", "#045FB4");
	        $.each(layer.screwline, function (index, line) {
	            line.setAttr("fill", "#F6CECE");
	            line.setAttr("stroke", "#FA5858");
	        });
	    }
	    layer.draw();
	});
	layer.on("select", function () {
	    base.setAttr("fill", "#FF8000");
	    base.setAttr("stroke", "#B45F04");
	    layer.hand.setAttr("fill", "#FF8000");
	    layer.hand.setAttr("stroke", "#B45F04");
	    $.each(layer.screwline, function (index, line) {
	        line.setAttr("fill", "#FF8000");
	        line.setAttr("stroke", "#B45F04");
	    });
	    layer.draw();
	});

    return layer;
}

function pulley (layer,x,y) {
	layer.remove();
	layer = new Kinetic.Layer();
	var r = Math.linear.getPointDistance(mousestartx,mousestarty,x,y,true);
	var pulley = new Kinetic.Circle({
		x: mousestartx,
		y: mousestarty,
		radius: r,
		fill: '#CEF6F5',
		stroke: '#2E64FE',
		strokeWidth: 4,
		draggable: true
	});
	pulley.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			layer.center = {x:pos.x,y:pos.y};
			pulleyupdaterope(layer);
			return {
				x: pos.x,
				y: pos.y
			};
		} else {
			return {x:layer.center.x,y:layer.center.y};
		}
	});
	layer.add(pulley);
	stage.add(layer);
	
	this.mouseover = false;
	layer.center = {x:mousestartx,y:mousestarty};
	layer.rope = [];
	layer.pulleytype = 0; //0 = normalup 1 = normaldown 2 = moveupleft 3 = moveupright 4 = movedownleft 5 = movedownright
	layer.r = r;
	layer.leftrope = pulleyrope(layer,layer.center.x-layer.r,layer.center.y,layer.center.y+100,false);
	layer.rightrope = pulleyrope(layer,layer.center.x+layer.r,layer.center.y,layer.center.y+100,false);
	layer.middlerope = pulleyrope(layer,layer.center.x,layer.center.y-layer.r,38,true);
	layer.type = "pulley";
	layer.weight = 0;
	
	layer.on("dragmove",function() {
		selectiondrag(this);
	});

	layer.on("dragend",function() {
		selectiondragend(pulley);
	});

	layer.on("mousedown",function(e) {
		ondragobj = this;
	});
	layer.on("mouseover",function(e) {
		this.mouseover = true;
		if (!this.selected) {
			pulley.setAttr("fill","#FAAC58");
			pulley.setAttr("stroke","#B45F04");
			layer.draw();
		}
	});
	layer.on("mouseout",function(e) {
		this.mouseover = false;
		if (!this.selected) {
			pulley.setAttr("fill","#CEF6F5");
			pulley.setAttr("stroke","#2E64FE");
			layer.draw();
		}
	});
	layer.on("unselect",function(e) {
		if (this.mouseover) {
			pulley.setAttr("fill","#FAAC58");
			pulley.setAttr("stroke","#B45F04");
		} else {
			pulley.setAttr("fill","#CEF6F5");
			pulley.setAttr("stroke","#2E64FE");
		}
		layer.draw();
	});
	layer.on("select",function() {
		pulley.setAttr("fill","#FF8000");
		pulley.setAttr("stroke","#B45F04");
		layer.draw();
	});
	layer.on("mousedown touchstart",function(e) {
		/*if (currenttool == 8) {
			var xobj = layer.center.x;
			if (stage.getPointerPosition().x > layer.center.x) {
				xobj += r;
			} else {
				xobj -= r;
			}
			currenttooloverride = true;
			currenttoolcallback = pulleyrope;
			currenttoolarg = {layer:new Kinetic.Layer(),pulley:layer,xobj:xobj,yobj:layer.center.y};
		}*/
	});
	
	return layer;
}

function slide (layer,x,y) {
	layer.remove();
	layer = new Kinetic.Layer();
	if (y>mousestarty) {
		layer.xstart = mousestartx;
		layer.ystart = mousestarty;
		layer.xend = x;
	} else {
		layer.xstart = x;
		layer.ystart = y;
		layer.xend = mousestartx;
	}
	var slide = new Kinetic.Line({
		points: [layer.xstart,layer.ystart,layer.xstart,stageh-60,layer.xend,stageh-60],
		fill: '#81F781',
		stroke: '#04B431',
		strokeWidth: 5,
		closed: true,
		draggable: true
	});
	slide.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			//Update object position
			$.each(layer.objects,function(index,obj) {
				obj.setAbsolutePosition({x:pos.x,y:0});
				obj.draw();
			});
			return {
				x: pos.x,
				y: 0
			}
		} else {
			return {x:0,y:0}
		}
	});
	slide.on("dragend",function() {
		layer.xstart = layer.xstart+slide.getAbsolutePosition().x;
		layer.xend = layer.xend+slide.getAbsolutePosition().x;
		slide.points([layer.xstart,layer.ystart,layer.xstart,stageh-60,layer.xend,stageh-60]);
		slide.setAbsolutePosition({x:0,y:0});
		
		//Update object position
		$.each(layer.objects,function(index,obj) {
			var points = obj.getChildren()[0].points();
			obj.getChildren()[0].points([points[0]+obj.getAbsolutePosition().x, points[1], points[2]+obj.getAbsolutePosition().x, points[3], points[4]+obj.getAbsolutePosition().x, points[5], points[6]+obj.getAbsolutePosition().x, points[7]]);
			obj.setAbsolutePosition({x:0,y:0});
			obj.draw();
		});
		
		//Update equation and angle
		layer.angle = Math.atan(((stageh-60)-layer.ystart)/(Math.max(layer.xstart,layer.xend)-Math.min(layer.xstart,layer.xend)))*(180/Math.PI);
		layer.equation = Math.linearCanvas.create(layer.xstart,layer.ystart,layer.xend,stageh-60).parallelD(-4);
		
		updateobjectslide(layer);
	});
	layer.add(slide);
	stage.add(layer);
	layer.angle = Math.atan(((stageh-60)-layer.ystart)/(Math.max(layer.xstart,layer.xend)-Math.min(layer.xstart,layer.xend)))*(180/Math.PI);
	layer.equation = Math.linearCanvas.create(layer.xstart,layer.ystart,layer.xend,stageh-60).parallelD(-4);
	
	layer.type = "slide";
	layer.objects = [];
	
	layer.u = 0;
	
	slide.on("mousedown touchstart",function(e) {
		if (currenttool == 0) {
			currenttooloverride = true;
			currenttoolcallback = objectslide;
			var y = ((Math.sin(layer.angle*(Math.PI/180))))/((Math.sin((90-layer.angle)*(Math.PI/180))))*(stage.getPointerPosition().x-layer.xstart);
			currenttoolarg = {layer:new Kinetic.Layer(),slide:layer,xstart:stage.getPointerPosition().x,ystart:Math.abs(y)+layer.ystart};
		}
	});
	layer.on("dragmove",function() {
		selectiondrag(this);
	});

	layer.on("dragend",function() {
		selectiondragend(slide);
	});

	layer.on("mousedown",function(e) {
		ondragobj = this;
	});
	layer.on("mouseover",function(e) {
		this.mouseover = true;
		if (!this.selected) {
			slide.setAttr("fill","#FAAC58");
			slide.setAttr("stroke","#B45F04");
			layer.draw();
		}
	});
	layer.on("mouseout",function(e) {
		this.mouseover = false;
		if (!this.selected) {
			slide.setAttr("fill","#81F781");
			slide.setAttr("stroke","#04B431");
			layer.draw();
		}
	});
	layer.on("unselect",function(e) {
		if (this.mouseover) {
			slide.setAttr("fill","#FAAC58");
			slide.setAttr("stroke","#B45F04");
		} else {
			slide.setAttr("fill","#81F781");
			slide.setAttr("stroke","#04B431");
		}
		layer.draw();
	});
	layer.on("select",function() {
		slide.setAttr("fill","#FF8000");
		slide.setAttr("stroke","#B45F04");
		layer.draw();
	})
	
	return layer;
}

			/*$.each(obj.objects,function(index,obj2) {
				if (obj2.centerori > obj.fulcrum) {
					obj.ani.momentr = obj.ani.momentr+(obj2.weight*(obj2.center-obj.fulcrum));
				} else {
					obj.ani.momentl = obj.ani.momentl+(obj2.weight*(obj.fulcrum-obj2.center));
				}
			});*/

function calmoment (beam) {
	var momentr = 0;var momentl = 0;
	var center = (beam.xmax+beam.xmin)/2;
	/*if (beam.fulcrum > center) {
		momentl += ((beam.weight/1000*g)*(beam.fulcrum-center)*pixel2m);
	} else {
		momentr += ((beam.weight/1000*g)*(center-beam.fulcrum)*pixel2m);
	}*/
	$.each(beam.forces,function(index,f) {
		var angle = f.angle+beam.angle;
		var forceresult = Math.abs(f.force*Math.cos(angle*(Math.PI/180))*Math.abs(f.xstart-beam.fulcrum)*pixel2m);
		var up = f.up;
		if (f.reverse) {up = !up;}
		if (f.xstart > beam.fulcrum) {
			if (up) {
				momentl += forceresult;
			} else {
				momentr += forceresult;
			}
		} else {
			if (up) {
				momentr += forceresult;
			} else {
				momentl += forceresult;
			}
		}
	});
	$.each(beam.objects,function(index,obj) {
		if (obj.centerori > beam.fulcrum) {
			momentr = momentr+((obj.weight/1000*g)*((obj.center-beam.fulcrum)*pixel2m));
		} else {
			momentl = momentl+((obj.weight/1000*g)*((beam.fulcrum-obj.center)*pixel2m));
		}
	});
	return {momentr: momentr,momentl: momentl};
}

function objectbeamupdatecenter (beam) {
	beam.objcentermin = -1;beam.objcentermax = -1;
	$.each(beam.objects,function(index,obj) {
		if (beam.objcentermin == -1 || obj.centerori<beam.objcentermin) {
			beam.objcentermin = obj.centerori;
		}
		if (beam.objcentermax == -1 || obj.centerori>beam.objcentermax) {
			beam.objcentermax = obj.centerori;
		}
	});
}

function objectbeam (arg) {
	var obj = object(new Kinetic.Layer(),arg.xobj,arg.yobj-2,arg.x,arg.y);
	arg.beam.objects.push(obj);
	obj.center = obj.centerori = (obj.xmax+obj.xmin)/2;
	var moment = calmoment(arg.beam);
	arg.beam.momentr = moment.momentr;
	arg.beam.momentl = moment.momentl;
	obj.draggable(true);
	obj.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			var x = pos.x;
			if (this.xmin+pos.x>arg.beam.xmax-((this.xmax-this.xmin)/2)) {
				x = (arg.beam.xmax-((this.xmax-this.xmin)/2))-this.xmin;
			} else if (this.xmin+pos.x<arg.beam.xmin-((this.xmax-this.xmin)/2)) {
				x = (arg.beam.xmin-((this.xmax-this.xmin)/2))-this.xmin;
			}
			return {
				x:x,
				y:0
			};
		} else {
			return {x:0,y:0};
		}
	});
	obj.on("dragmove",function() {
		selectiondrag(this);
	});
	//Update points (Fix ani bug) moment ...
	obj.on("dragend",function() {
		selectiondragend(this);
		
		var bounds = getobjectbounds(this,false);
		this.setAbsolutePosition({x:0,y:0});
		this.getChildren()[0].points([bounds.xmin,bounds.ymin,bounds.xmin,bounds.ymax,bounds.xmax,bounds.ymax,bounds.xmax,bounds.ymin]);
		this.draw();
		
		this.xmin = bounds.xmin;
		this.xmax = bounds.xmax;
		this.ymin = bounds.ymin;
		this.ymax = bounds.ymax;
		this.center = this.centerori = (this.xmax+this.xmin)/2;
		var moment = calmoment(arg.beam);
		arg.beam.momentr = moment.momentr;
		arg.beam.momentl = moment.momentl;
		
		objectbeamupdatecenter(arg.beam);
	});
	obj.instanceof = arg.beam;
	
	objectbeamupdatecenter(arg.beam);
	
	//updatestatus();
	return obj;
}

function setobjectslidecenter (obj,x,y) {
	
	var slide = obj.instanceof;
	var line1 = slide.equation.perpendicular(x,y);
	var line2 = line1.parallelD(obj.width/2);
	var line3 = line1.parallelD(-(obj.width/2));
	var line4 = slide.equation.parallelD(obj.height);
	var point1 = line2.intersection(line4);
	var point2 = line2.intersection(slide.equation);
	var point3 = line3.intersection(slide.equation);
	var point4 = line3.intersection(line4);

	obj.getChildren()[0].points([point1.x,point1.y,point2.x,point2.y,point3.x,point3.y,point4.x,point4.y]);
	
	obj.draw();
	
	obj.center = {x:x,y:y};
	obj.dfromend = Math.linear.getPointDistance(obj.center.x,obj.center.y,slide.xend,stageh-60,true);
	
	$.each(obj.forces,function (index,f) {
		
		var line1 = obj.instanceof.equation.parallelD(f.dfromslide);
		var line2 = obj.instanceof.equation.perpendicular(obj.center.x,obj.center.y);
		var line3 = line2.parallelD(obj.width/2);
		var line4 = line2.parallelD(-(obj.width/2));
		var pointright = line1.intersection(line3);
		var pointleft = line1.intersection(line4);
		
		if (obj.instanceof.xstart < obj.instanceof.xend) {
			if (f.left) {
				f.xstart = pointleft.x;
				f.ystart = pointleft.y;
				var angle = f.instanceof.instanceof.angle-90;
			} else {
				f.xstart = pointright.x;
				f.ystart = pointright.y;
				var angle = f.instanceof.instanceof.angle+90;
			}
		} else {
			if (!f.left) {
				f.xstart = pointleft.x;
				f.ystart = pointleft.y;
				var angle = 90-f.instanceof.instanceof.angle;
			} else {
				f.xstart = pointright.x;
				f.ystart = pointright.y;
				var angle = -90-f.instanceof.instanceof.angle;
			}
		}
		
		forcerotate(f,angle,true);
		
	});
	
}

function setobjectslidepos (obj,d) {
	var slide = obj.instanceof;
	var center = slide.equation.translate(slide.xend,stageh-60,-d);
	var result = true;
	//console.log(slide.xstart+" "+center.x);
	if ((slide.xstart > slide.xend && center.x > slide.xstart) || (slide.xstart < slide.xend && center.x < slide.xstart) || isNaN(center.x)) {
		return false;
	}
	setobjectslidecenter(obj,Math.abs(center.x),Math.abs(center.y));
	return true;
}

function setobjectslidepostest (obj,d) {
	var slide = obj.instanceof;
	var center = slide.equation.translate(slide.xend,stageh-60,-d);
	var result = true;
	//console.log(slide.xstart+" "+center.x);
	if ((slide.xstart > slide.xend && center.x > slide.xstart) || (slide.xstart < slide.xend && center.x < slide.xstart) || isNaN(center.x)) {
		return false;
	}
	return true;
}

function updateobjectslide (slide) {
	var result = true;
	$.each(slide.objects,function(index,obj) {
		if (result) {
			result = setobjectslidepos(obj,obj.dfromend);
		}
	});
	return result;
}

function updateobjectslidetest (slide) {
	var result = true;
	$.each(slide.objects,function(index,obj) {
		if (result) {
			result = setobjectslidepostest(obj,obj.dfromend);
		}
	});
	return result;
}

function forceobjectslide (arg) {
	
	if (arg.obj.instanceof.xstart < arg.obj.instanceof.xend) {
		if (arg.x < arg.xobj) {
			var xobj = arg.pointleft.x;
			var yobj = arg.pointleft.y;
			var angle = arg.obj.instanceof.angle-90;
			var up = true;
			var left = true;
		} else {
			var xobj = arg.pointright.x;
			var yobj = arg.pointright.y;
			var angle = arg.obj.instanceof.angle+90;
			var up = false;
			var left = false;
		}
	} else {
		if (arg.x > arg.xobj) {
			var xobj = arg.pointleft.x;
			var yobj = arg.pointleft.y;
			var angle = 90-arg.obj.instanceof.angle;
			var up = true;
			var left = false;
		} else {
			var xobj = arg.pointright.x;
			var yobj = arg.pointright.y;
			var angle = -90-arg.obj.instanceof.angle;
			var up = false;
			var left = true;
		}
	}

	var f = force(new Kinetic.Layer(),xobj,yobj,arg.x,arg.y);
	f.up = up;
	f.left = left;
	f.lockangle = true;
	f.instanceof = arg.obj;
	f.dfromslide = arg.obj.instanceof.equation.getperpendicularD(arg.xobj,arg.yobj,false);
	
	forcerotate(f,angle,true);

	arg.obj.forces.push(f);
	
	return f;
}

function objectslide (arg) {
	//var x1,y1,x2,y2,x3,y3,x4,y4;
	var line1 = arg.slide.equation.perpendicular(arg.xstart,arg.ystart);
	var line2 = arg.slide.equation.perpendicular(arg.x,arg.y);
	var line3 = line1.perpendicular(arg.x,arg.y);
	var point1 = line3.intersection(line1);
	var point2 = line1.intersection(arg.slide.equation);
	var point3 = line2.intersection(arg.slide.equation);
	
	var obj = object2(arg.layer,[point1.x, point1.y, point2.x, point2.y, point3.x, point3.y, arg.x, arg.y]);
	
	obj.draggable(true);
	obj.dragBoundFunc(function (pos) {
		if (currenttool == -1) {
			var x = pos.x;
			if (obj.center.x+x < Math.min(arg.slide.xstart,arg.slide.xend)) {
				x = Math.min(arg.slide.xstart,arg.slide.xend)-obj.center.x;
			} else if (obj.center.x+x > Math.max(arg.slide.xstart,arg.slide.xend)) {
				x = Math.max(arg.slide.xstart,arg.slide.xend)-obj.center.x;
			}
			var y = arg.slide.equation.getY(obj.center.x+x)-obj.center.y;

			return {x:x,y:y};
		} else { return {x:0,y:0}; }
	});
	
	obj.on("dragmove",function() {
		selectiondrag(this);
	});

	obj.on("dragend",function() {
		selectiondragend(obj);
		
		var pos = obj.getAbsolutePosition();
		setobjectslidecenter(this,obj.center.x+pos.x,obj.center.y+pos.y);
		obj.setAbsolutePosition({x:0,y:0});
	});
	
	obj.width = line1.getparallelD(line2);
	obj.height = arg.slide.equation.getparallelD(line3);
	obj.center = line1.parallelD(obj.width/2).intersection(arg.slide.equation);
	obj.dfromend = Math.linear.getPointDistance(obj.center.x,obj.center.y,arg.slide.xend,stageh-60,true);
	console.log(obj.height);
	
	arg.slide.objects.push(obj);
	obj.instanceof = arg.slide;
	
	obj.forces = [];
	
	obj.on("mousedown touchstart",function(e) {
		if (currenttool == 7) {
			currenttooloverride = true;
			currenttoolcallback = forceobjectslide;
			var line1 = obj.instanceof.equation.parallel(stage.getPointerPosition().x,stage.getPointerPosition().y);
			var line2 = obj.instanceof.equation.perpendicular(obj.center.x,obj.center.y);
			var line3 = line2.parallelD(obj.width/2);
			var line4 = line2.parallelD(-(obj.width/2));
			var pointright = line1.intersection(line3);
			var pointleft = line1.intersection(line4);
			currenttoolarg = {layer:new Kinetic.Layer(),obj:obj,xobj:stage.getPointerPosition().x,yobj:stage.getPointerPosition().y,pointright:pointright,pointleft:pointleft};
		}
	});
	
	return obj;
}

function object (layer,x1,y1,x2,y2) {
	var xmax = Math.max(x1,x2);
	var ymax = Math.max(y1,y2);
	var xmin = Math.min(x1,x2);
	var ymin = Math.min(y1,y2);
	layer.remove();
	layer = new Kinetic.Layer();
	var obj = new Kinetic.Line({
		points: [xmin, ymin, xmin, ymax, xmax, ymax, xmax, ymin],
		fill: '#8080FF',
		stroke: '#0000FF',
		strokeWidth: 4,
		closed: true
	});
	/*var wtext = new Kinetic.Text({
	    x: xmin,
	    y: ymax,
	    text: 'W',
	    fontSize: 24,
	    fontFamily: 'LayijiMaHaNiYomV15Regular',
	    width: xmax - xmin,
	    align: 'center',
	    fill: 'white'
	});*/
    /*var obj = new Kinetic.Rect({
		x: xmin,
		y: ymin,
		width: xmax-xmin,
		height: ymax-ymin,
		fill: '#8080FF',
		stroke: '#0000FF',
		strokeWidth: 4,
		offset: {x:0,y:0}
	});*/
	layer.add(obj);
	//layer.add(wtext);
	stage.add(layer);
	layer.weight = 50;
	layer.xmin = xmin;
	layer.ymin = ymin;
	layer.xmax = xmax;
	layer.ymax = ymax;
	layer.width = xmax-xmin;
	layer.height = ymax-ymin;
	layer.type = "object";
	layer.center = layer.centerori = (xmax+xmin)/2;
	layer.on("mousedown",function(e) {
		ondragobj = this;
	});
	layer.on("mouseover",function(e) {
		this.mouseover = true;
		if (!this.selected) {
			obj.setAttr("fill","#FAAC58");
			obj.setAttr("stroke","#B45F04");
			layer.draw();
		}
	});
	layer.on("mouseout",function(e) {
		this.mouseover = false;
		if (!this.selected) {
			obj.setAttr("fill","#8080FF");
			obj.setAttr("stroke","#0000FF");
			layer.draw();
		}
	});
	layer.on("unselect",function(e) {
		if (this.mouseover) {
			obj.setAttr("fill","#FAAC58");
			obj.setAttr("stroke","#B45F04");
		} else {
			obj.setAttr("fill","#8080FF");
			obj.setAttr("stroke","#0000FF");
		}
		layer.draw();
	});
	layer.on("select",function() {
		obj.setAttr("fill","#FF8000");
		obj.setAttr("stroke","#B45F04");
		layer.draw();
	})
	/*layer.on("dragmove",function(e) {
		
	});*/
	return layer;
}

function object2 (layer,points) {
	layer.remove();
	layer = new Kinetic.Layer();
	var obj = new Kinetic.Line({
		points: points,
		fill: '#8080FF',
		stroke: '#0000FF',
		strokeWidth: 4,
		closed: true
	});
    /*var obj = new Kinetic.Rect({
		x: xmin,
		y: ymin,
		width: xmax-xmin,
		height: ymax-ymin,
		fill: '#8080FF',
		stroke: '#0000FF',
		strokeWidth: 4,
		offset: {x:0,y:0}
	});*/
	layer.add(obj);
	stage.add(layer);
	layer.id = objects.length;
	layer.weight = 50;
	layer.type = "object";

	layer.on("mousedown",function(e) {
		ondragobj = this;
	});
	layer.on("mouseover",function(e) {
		this.mouseover = true;
		if (!this.selected) {
			obj.setAttr("fill","#FAAC58");
			obj.setAttr("stroke","#B45F04");
			layer.draw();
		}
	});
	layer.on("mouseout",function(e) {
		this.mouseover = false;
		if (!this.selected) {
			obj.setAttr("fill","#8080FF");
			obj.setAttr("stroke","#0000FF");
			layer.draw();
		}
	});
	layer.on("unselect",function(e) {
		if (this.mouseover) {
			obj.setAttr("fill","#FAAC58");
			obj.setAttr("stroke","#B45F04");
		} else {
			obj.setAttr("fill","#8080FF");
			obj.setAttr("stroke","#0000FF");
		}
		layer.draw();
	});
	layer.on("select",function() {
		obj.setAttr("fill","#FF8000");
		obj.setAttr("stroke","#B45F04");
		layer.draw();
	})
	/*layer.on("dragmove",function(e) {
		
	});*/
	return layer;
}

function drawmousedrag (x,y) {
	var xmax = Math.max(mousestartx,x);
	var ymax = Math.max(mousestarty,y);
	var xmin = Math.min(mousestartx,x);
	var ymin = Math.min(mousestarty,y);

	mousedraglayer.getChildren()[0].points([xmin, ymin, xmin, ymax, xmax, ymax, xmax, ymin]);
	mousedraglayer.getChildren()[1].points([mousestartx, mousestarty, x, y]);
	mousedraglayer.draw();

}

//createBeam (new Kinetic.Layer(), 500,500);

drawfloor();

function deleteobject(obj) {
    if (obj.type != "rope") {
        obj.remove();
        obj.active = false;
    }
    /*if (obj.objects) {
        $.each(obj.objects, function (index, obj2) {
            deleteobject(obj2);
        });
    }
    if (obj.forces) {
        $.each(obj.forces, function (index, f) {
            deleteobject(f);
        });
    }*/
    switch (obj.type) {
	    case "object":
	        if (obj.instanceof.objects) {
	            obj.instanceof.objects.splice(obj.instanceof.objects.indexOf(obj), 1);
	        }
	        break;
	    case "force":
	        if (obj.instanceof.forces) {
	            obj.instanceof.forces.splice(obj.instanceof.forces.indexOf(obj), 1);
	        }
	        break;
	    case "pulley":
	        deleteobject(obj.leftrope); obj.leftrope.remove();
	        deleteobject(obj.middlerope); obj.middlerope.remove();
	        deleteobject(obj.rightrope); obj.rightrope.remove();
	        break;
	    case "wheel":
	        deleteobject(obj.outerrope); obj.outerrope.remove();
	        deleteobject(obj.innerrope); obj.innerrope.remove();
	        break;
	    case "rope":
	        $.each(obj.objects.concat(obj.forces), function (index, target) {
	            deleteobject(target);
	        });
	        obj.objects = [];
	        obj.forces = [];
	        break;
    }

    clearselection();
    //updatestatus();
}

function clearscene() {
	$.each(objects,function (index,obj) {
		deleteobject(obj);
	});
	objects = [];
	//console.log(objects);
}

$(window).keyup(function(e){
    if(e.keyCode == 46) {
		var selected = getselectedobjects();
		$.each(selected,function (index,obj) {
			deleteobject(obj);
		});
	}
}) 
			
/*document.oncopy= function(){return false;} 
document.ondragstart= function(){return false;}
document.onselectstart= function(){return false;}*/

function performancetest() {
    if (performancetime == 0) {
        var test1 = run(true);
        var test2 = run(true);
        var test3 = run(true);
        var test4 = run(true);
        var test5 = run(true);
        performancetime = (test1 + test2 + test3 + test4 + test5) / 5;
    }
    run();
}
			
$("#sidetoolbar .toolbarbutton").click(function(e) {
	if ($(this).attr("class") == "toolbarbutton") {
		$("#sidetoolbar .toolbarbuttonactive").attr("class","toolbarbutton");
		$(this).attr("class","toolbarbuttonactive");
		currenttool = parseInt($(this).attr("data-id"));
		clearscene();
		var obj = null;
		onrun = false;
		switch (currenttool) {
		    case 1:
		        mousestartx = 50;
		        mousestarty = (stageh - 60) - 200;
			    obj = slide(new Kinetic.Layer(), 400, stageh - 60);
				var y = ((Math.sin(obj.angle*(Math.PI/180))))/((Math.sin((90-obj.angle)*(Math.PI/180))))*(320-obj.xstart);
				var w = objectslide({ layer: new Kinetic.Layer(), slide: obj, xstart: 320, ystart: Math.abs(y) + obj.ystart, x: 420, y: stageh - 60 - 75 });
				var line1 = obj.equation.parallel(340, stageh - 60 - 80);
				var line2 = obj.equation.perpendicular(w.center.x,w.center.y);
				var line3 = line2.parallelD(w.width/2);
				var line4 = line2.parallelD(-(w.width/2));
				var pointright = line1.intersection(line3);
				var pointleft = line1.intersection(line4);
				var e = forceobjectslide({ layer: new Kinetic.Layer(), obj: w, xobj: 340, yobj: stageh - 60 - 80, pointright: pointright, pointleft: pointleft, x: 280, y: stageh - 60 - 80 });
				objects.push(obj);
				objects.push(w);
				objects.push(e);
				break;
		    case 2:
		        mousestartx = 50;
		        mousestarty = (stageh - 60) - 150;
		        obj = beam(new Kinetic.Layer(), 400, stageh - 60 - 125);
		        var e = forcebeam({ layer: new Kinetic.Layer(), beam: obj, xobj: 400, yobj: stageh - 220, x: 400, y: stageh - 250 });
		        var w = objectbeam({ layer: new Kinetic.Layer(), beam: obj, xobj: 140, yobj: 220, x: 100, y: 180 });
		        e.reverse = true;
		        beamrotate(obj, 0);
		        objects.push(obj);
		        objects.push(w);
		        objects.push(e);
		        break;
		    case 3:
		        mousestartx = 50;
		        mousestarty = 100;
		        obj = pulley(new Kinetic.Layer(), 50, 125);
		        objects.push(obj);
				setTimeout(function() {setpulleytype(obj, 0)}, 10);
		        break;
		    case 4:
		        mousestartx = 50;
		        mousestarty = stageh - 60 - 200;
		        obj = wedge(new Kinetic.Layer(), 200, stageh - 60);
		        var e = forcewedge({ layer: new Kinetic.Layer(), wedge: obj, xobj: 125, yobj: stageh - 60 - 200, x: 125, y: stageh - 60 - 250 });
		        e.force = 2.5;
		        objects.push(obj);
		        objects.push(e);
		        resetscene(true);
		        break;
		    case 5:
		        mousestartx = 75;
		        mousestarty = 100;
		        obj = wheel(new Kinetic.Layer(), 100, 125);
		        var e = forcerope({ layer: new Kinetic.Layer(), rope: obj.outerrope, xobj: obj.outerrope.xend, yobj: obj.outerrope.yend, x: obj.outerrope.xend, y: obj.outerrope.yend + 50 });
		        var w = objectrope({ layer: new Kinetic.Layer(), rope: obj.innerrope, xobj: obj.innerrope.xend, yobj: obj.innerrope.yend, x: obj.innerrope.xend + 20, y: obj.innerrope.yend + 50 });
		        objects.push(obj);
		        objects.push(w);
		        objects.push(e);
		        break;
		    case 6:
		        mousestartx = 100;
		        mousestarty = stageh - 60 - 200;
		        obj = screw(new Kinetic.Layer(), 120, stageh - 60);
		        var w = objectscrew({ layer: new Kinetic.Layer(), screw: obj, xobj: 90, yobj: stageh - 70 - 200, x: 130, y: stageh - 70 - 230 });
		        objects.push(obj);
		        objects.push(w);
		        break;
		}
		if (obj != null) {
			obj.anchors = [];
			obj.selected = false;
			obj.ondrag = false;
			obj.ondragblocker = true;
			obj.id = objects.length;
			obj.active = true;
			//objects.push(obj);
		}
	} else {
		$(this).attr("class","toolbarbutton");
		currenttool = -1;
		clearscene();
	}
	updatestatus(); updateplottype();
	$(".runonly").css("opacity", "0.3");
    //$(".norunonly").css("opacity","1");

	$(".runbutton div").css("background-image", "url(images/toptoolbar/start.png)");
	$(".runbutton").attr("title", "เริ่มการจำลอง");

	//performancetime = performancetest();
	//setTimeout(function () { updatestatus(); updateplottype(); }, 10);
	//console.log(currenttool);
});

window.onresize = function () {
	initsize();
	drawfloor();
};

$("#mainarea").bind("mousedown vmousedown",function(e) {
	//if (!currenttooloverride) {
	var areaoffset = $(this).offset();
	mousestartx = e.pageX - areaoffset.left;
	mousestarty = e.pageY - areaoffset.top;
	//}
	mousedown = true;
	mousedraglayer.getChildren()[0].points([0, 0, 0, 0, 0, 0, 0, 0]);
	mousedraglayer.getChildren()[1].points([0, 0, 0, 0]);
	mousedraglayer.draw();
	stage.add(mousedraglayer);
});

$("#mainarea").bind("mouseup vmouseup",function(e) {
	/*var areaoffset = $(this).offset();
	var x = e.pageX - areaoffset.left;
	var y = e.pageY - areaoffset.top;
	var obj = null;
	if (currenttool == 0 || currenttool == 7 || currenttool == 8) {
		//object(new Kinetic.Layer(), x , y);
		if (currenttooloverride) {
			currenttoolarg.x = x;
			currenttoolarg.y = y;
			obj = currenttoolcallback(currenttoolarg);
		}
	}
	if (currenttool == 1) {
		obj = slide(new Kinetic.Layer(), x , y);
	}
	if (currenttool == 2) {
		obj = beam(new Kinetic.Layer(), x , y);
	}
	if (currenttool == 3) {
		obj = pulley(new Kinetic.Layer(), x , y);
	}
	if (currenttool == 4) {
		obj = wedge(new Kinetic.Layer(), x , y);
	}
	if (currenttool == 5) {
		obj = wheel(new Kinetic.Layer(), x , y);
	}
	if (currenttool == 6) {
	    obj = screw(new Kinetic.Layer(), x, y);
	}
	if (obj != null) {
		obj.anchors = [];
		obj.selected = false;
		obj.ondrag = false;
		obj.ondragblocker = true;
		obj.id = objects.length;
		obj.active = true;
		objects.push(obj);
	}*/
	mousestartx = -1;
	mousestarty = -1;
	currenttooloverride = false;
	mousedown = false;
});

$("body").bind("mouseup vmouseup",function(e) {
	mousedraglayer.remove();
});

$("#mainarea").bind("mousemove vmousemove",function(e) {
	var areaoffset = $(this).offset();
	var x = e.pageX - areaoffset.left;
	var y = e.pageY - areaoffset.top;
	if (mousedown && mousedrageffect) {
		drawmousedrag(x,y);
	}
});

var runfunc;
var onrun = false;
var onplot = false;
var runpause = false;

function resetbeam (beam) {
	beamrotate(beam,0);
	beam.getChildren()[0].draggable(true);
	beam.getChildren()[1].draggable(true);
}

function resetslide (slide) {
	slide.getChildren()[0].draggable(true);
	$.each(slide.objects,function(index,obj) {
		setobjectslidepos(obj,obj.ani.dori);
		
		$.each(obj.forces,function(index,f) {
			setTimeout (function () {
				f.draggable(false);
				f.getChildren()[0].draggable(false);
			},10);
		})
	});	
}

function resetwedge (wedge) {
	wedge.getChildren()[0].draggable(true);
	wedge.getChildren()[0].points([wedge.xstart,wedge.ystart,wedge.xend,wedge.ystart,(wedge.xstart+wedge.xend)/2,stageh-63]);
	wedge.draw();
	$.each(wedge.objects,function(index,obj) {
		obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
		obj.draw();
	});	
	$.each(wedge.forces,function(index,f) {
		f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart,f.xend,f.yend,f.reverse));
		f.draw();
	});	
}

function resetwheel (wheel) {
	wheel.setAbsolutePosition({x:0,y:0});
	wheel.draw();
	wheelupdaterope(wheel);
}

function resetpulley (pulley) {
	pulley.setAbsolutePosition({x:0,y:0});
	pulley.draw();
	pulleyupdaterope(pulley);
	/*pulley.leftrope.getChildren()[0].points([pulley.leftrope.xstart,pulley.leftrope.ystart,pulley.leftrope.xend,pulley.leftrope.yend]);
	pulley.rightrope.getChildren()[0].points([pulley.rightrope.xstart,pulley.rightrope.ystart,pulley.rightrope.xend,pulley.rightrope.yend]);
	pulley.middlerope.getChildren()[0].points([pulley.middlerope.xstart,pulley.middlerope.ystart,pulley.middlerope.xend,pulley.middlerope.yend]);
	pulley.leftrope.draw();
	pulley.rightrope.draw();
	pulley.middlerope.draw();
	$.each(pulley.leftrope.objects.concat(pulley.rightrope.objects).concat(pulley.middlerope.objects),function(index,obj) {
		obj.getChildren()[0].points([obj.xmin, obj.ymin, obj.xmin, obj.ymax, obj.xmax, obj.ymax, obj.xmax, obj.ymin]);
		setTimeout(function () {
			obj.draggable(false);
		},10);
		obj.draw();
	});	
	$.each(pulley.leftrope.forces.concat(pulley.rightrope.forces).concat(pulley.middlerope.forces),function(index,f) {
		f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart,f.xend,f.yend,f.reverse));
		setTimeout(function () {
			f.draggable(false);
		},10);
		f.draw();
	});*/
}

function resetscrew(screw) {
    updatescrew(screw);
}


function resetscene (force) {
	if ($(".resetbutton").css("opacity") != 1 && !force) {
		return;
	}
	$.each(objects,function (index,obj) {
		if (obj.type != "rope") {
			obj.draggable(true);
		}
		switch (obj.type) {
			case "beam": resetbeam(obj); break;
			case "slide": resetslide(obj); break;
			case "wedge": resetwedge(obj); break;
			case "pulley": resetpulley(obj); break;
		    case "wheel": resetwheel(obj); break;
		    case "screw": resetscrew(obj); break;
		}
		obj.ani = null;
	});
	$(".runonly").css("opacity", "0.3");
	//$(".norunonly").css("opacity","1");
	
	$(".runbutton div").css("background-image", "url(images/toptoolbar/start.png)");
	$(".runbutton").attr("title", "เริ่มการจำลอง");
	onrun = false;
	runpause = false;
	
	/*var selected = getselectedobjects();
	$.each(selected,function(index,select) {
		objcreateanchor(select);
	});*/

	updatestatus();
	while (chart.series.length > 0) chart.series[0].remove(true);
}

function pause () {
	runpause = !runpause;
	if (runpause) {
	    $(".runbutton div").css("background-image", "url(images/toptoolbar/start.png)");
	    $(".runbutton").attr("title", "เริ่มการจำลอง");
	} else {
	    $(".runbutton div").css("background-image", "url(images/toptoolbar/pause.png)");
	    $(".runbutton").attr("title", "พักการจำลอง");
	}
}

function plotgraph (seriesid,data,t) {
	data = data*1; //Fix mystery decimal bug
	t = t*1; //Fix mystery decimal bug
	var series = chart.series[seriesid];
	//if (typeof data != "undefined") {
	series.addPoint([t, data], true);
	//}
}

function startplot(time) {
    onplot = true;
	var selected = getselectedobjects();
	selected = selected[0];
	var plottype = $("#chartdialog .starter .option").val();
	var t = 0.00;
	var interval = setInterval(function () {
		switch (plottype) {
			case "beam0":
				//console.log(t);
				plotgraph(0,selected.ani.momentrarray[t],t);
				plotgraph(1,selected.ani.momentlarray[t],t);
				break;
			case "objslide0":
				var a = (/*slidenominus*/((selected.weight/1000*g)*(Math.sin(selected.instanceof.angle*Math.PI/180)-selected.instanceof.u*Math.cos(selected.instanceof.angle*Math.PI/180)))-selected.ani.totalf)/(selected.weight/1000)/pixel2m;
				plotgraph(0,-(a*t*pixel2m),t);
				break;
			case "objslide1":
				var a = (/*slidenominus*/((selected.weight/1000*g)*(Math.sin(selected.instanceof.angle*Math.PI/180)-selected.ani.totalf-selected.instanceof.u*Math.cos(selected.instanceof.angle*Math.PI/180)))-selected.ani.totalf)/(selected.weight/1000)/pixel2m;
				var dcurr = 1/2*a*t*t;
				var dnew = (selected.dfromend-dcurr)-(selected.width/2);
				plotgraph(0,dnew*pixel2m,t);
				break;
			case "objslide2":
				var slided = Math.linear.getPointDistance(selected.instanceof.xstart,selected.instanceof.ystart,selected.instanceof.xend,stageh-60,true);
				
				var a = (/*slidenominus*/((selected.weight/1000*g)*(Math.sin(selected.instanceof.angle*Math.PI/180)-selected.instanceof.u*Math.cos(selected.instanceof.angle*Math.PI/180)))-selected.ani.totalf)/(selected.weight/1000)/pixel2m;
				var dcurr = 1/2*a*t*t;
				var dnew = (slided-(selected.dfromend-dcurr))-(selected.width/2);
				plotgraph(0,dnew*pixel2m,t);
				break;
			case "wedge0":
				plotgraph(0,selected.ani.sarray[t],t);
				break;
			case "pulley0":
				plotgraph(0,(stageh-60-selected.ani.yarray[t])*pixel2m,t);
				break;
			case "pulley1":
				plotgraph(0,Math.abs(selected.ani.leftyarray[t]-selected.ani.yarray[t])*pixel2m,t);
				plotgraph(1,Math.abs(selected.ani.middleyarray[t]-selected.ani.yarray[t])*pixel2m,t);
				if (selected.middlerope.up) {
				    plotgraph(2, Math.abs(selected.ani.middleyarray[t] - (selected.ani.yarray[t] - selected.r)) * pixel2m, t);
				} else {
				    plotgraph(2, Math.abs(selected.ani.middleyarray[t] - (selected.ani.yarray[t] + selected.r)) * pixel2m, t);
				}
				break;
		    case "wheel0":
		        //console.log(Math.abs(selected.ani.outeryarray[t] - selected.center.y) * pixel2m);
		        plotgraph(0, Math.abs(selected.ani.outeryarray[t] - selected.center.y) * pixel2m, t);
		        plotgraph(1, Math.abs(selected.ani.inneryarray[t] - selected.center.y) * pixel2m, t);
		        break;
		    case "ropewheel0":
		        selected.ani.endt = selected.instanceof.ani.endt;
		        var ropetype = 0; //left right middle
		        if (selected.id == selected.instanceof.innerrope.id) {
		            ropetype = 1;
		        }
		        switch (ropetype) {
		            case 0: plotgraph(0, Math.abs(selected.instanceof.ani.outeryarray[t] - selected.instanceof.center.y) * pixel2m, t); break;
		            case 1: plotgraph(0, Math.abs(selected.instanceof.ani.inneryarray[t] - selected.instanceof.center.y) * pixel2m, t); break;
		        }
		        break;
		    case "ropewheel1":
		        selected.ani.endt = selected.instanceof.ani.endt;
		        var ropetype = 0; //left right middle
		        if (selected.id == selected.instanceof.innerrope.id) {
		            ropetype = 1;
		        }
		        switch (ropetype) {
		            case 0:
		                if (selected.up) {
		                    plotgraph(0, (selected.instanceof.ani.outeryarray[t] - 40) * pixel2m, t);
		                } else {
		                    plotgraph(0, (stageh - 60 - selected.instanceof.ani.outeryarray[t]) * pixel2m, t);
		                }
		                break;
		            case 1:
		                if (selected.up) {
		                    plotgraph(0, (selected.instanceof.ani.inneryarray[t] - 40) * pixel2m, t);
		                } else {
		                    plotgraph(0, (stageh - 60 - selected.instanceof.ani.inneryarray[t]) * pixel2m, t);
		                }
		                break;
		        }
		        break;
			case "ropepulley0":
				selected.ani.endt = selected.instanceof.ani.endt;
				var ropetype = 0; //left right middle
				if (selected.id == selected.instanceof.rightrope.id) {
					ropetype = 1;
				} else if (selected.id == selected.instanceof.middlerope.id) {
					ropetype = 2;
				}
				switch (ropetype) {
					case 0: plotgraph(0,Math.abs(selected.instanceof.ani.leftyarray[t]-selected.instanceof.ani.yarray[t])*pixel2m,t); break;
					case 1: plotgraph(0,Math.abs(selected.instanceof.ani.rightyarray[t]-selected.instanceof.ani.yarray[t])*pixel2m,t); break;
					case 2: 
						if (selected.up) {
							plotgraph(0,Math.abs(selected.instanceof.ani.middleyarray[t]-(selected.instanceof.ani.yarray[t]-selected.instanceof.r))*pixel2m,t);
						} else {
							plotgraph(0,Math.abs(selected.instanceof.ani.middleyarray[t]-(selected.instanceof.ani.yarray[t]+selected.instanceof.r))*pixel2m,t);
						}
						break;
				}
				break;
			case "ropepulley1":
				selected.ani.endt = selected.instanceof.ani.endt;
				var ropetype = 0; //left right middle
				if (selected.id == selected.instanceof.rightrope.id) {
					ropetype = 1;
				} else if (selected.id == selected.instanceof.middlerope.id) {
					ropetype = 2;
				}
				switch (ropetype) {
					case 0:
						if (selected.up) {
							plotgraph(0,(selected.instanceof.ani.leftyarray[t]-40)*pixel2m,t);
						} else {
							plotgraph(0,(stageh-60-selected.instanceof.ani.leftyarray[t])*pixel2m,t);
						}
						break;
					case 1:
						if (selected.up) {
							plotgraph(0,(selected.instanceof.ani.rightyarray[t]-40)*pixel2m,t);
						} else {
							plotgraph(0,(stageh-60-selected.instanceof.ani.rightyarray[t])*pixel2m,t);
						}
						break;
					case 2:
						if (selected.up) {
							plotgraph(0,(selected.instanceof.ani.middleyarray[t]-40)*pixel2m,t);
						} else {
							plotgraph(0,(stageh-60-selected.instanceof.ani.middleyarray[t])*pixel2m,t);
						}
						break;
				}
				break;
		    case "screw0":
		        plotgraph(0, (selected.y - selected.ani.sarray[t] - 40) * pixel2m, t);
		        break;
		}
		t += 0.01;
		try {
			if (!selected.ani.endt) {
				throw ""; //Force error
			}
			if (t >= selected.ani.endt || !onplot) {
				clearInterval(interval);
				chart.redraw();
				resetscene();
				//$("#chart").css("display", "block"); chart.reflow();
				$(".chartrun").button('option', 'label', 'เริ่ม');
				onplot = false;
			}
		} catch (e) {
			if (time) {
			    if (t == time + 0.01 || !onplot) {
					clearInterval(interval);
					chart.redraw();
					resetscene();
					//$("#chart").css("display", "block"); chart.reflow();
					$(".chartrun").button('option', 'label', 'เริ่ม');
					onplot = false;
				} else if (t > time) {
					t = time;
				}
			} else {
				try {
				    if (t >= selected.instanceof.ani.endt || !onplot) {
						clearInterval(interval);
						chart.redraw();
						resetscene();
						//$("#chart").css("display", "block"); chart.reflow();
						$(".chartrun").button('option', 'label', 'เริ่ม');
						onplot = false;
					}
				} catch (e) {clearInterval(interval);}
			}
		}
	},1);
}

function graphinit () {
	while( chart.series.length > 0 ) {
		chart.series[0].remove(false);
	}

	chart.redraw();
	
	var type = $("#chartdialog .starter .option").val();
	switch (currenttool) {
	    case 1:
	        chart.addSeries({ name: "อัตราเร็ว (v) ของวัตถุ" });
	        chart.addSeries({ name: "ระยะทางจากพื้นของวัตถุ" });
	        chart.addSeries({ name: "ระยะทางจากจุดยอดของวัตถุ" });
	        break;
	    case 2:
	        chart.addSeries({ name: "โมเมนต์ตาม" });
	        chart.addSeries({ name: "โมเมนต์ทวน" });
	        break;
	    case 3:
	        chart.addSeries({ name: "ระยะทางจากเชือกด้านซ้าย" });
	        chart.addSeries({ name: "ระยะทางจากเชือกตรงกลาง" });
	        chart.addSeries({ name: "ระยะทางจากเชือกด้านขวา" });
	        chart.addSeries({ name: "ระยะทางจากพื้น" });
	        //chart.addSeries({ name: "ระยะทางจากเพดาน" });
	        break;
	    case 4:
	        chart.addSeries({ name: "ระยะทางที่เจาะลงไป" });
	        chart.addSeries({ name: "อัตราเร็ว (v)" });
	        break;
	    case 5:
	        chart.addSeries({ name: "ระยะทางจากแรงพยายาม" });
	        chart.addSeries({ name: "ระยะทางจากแรงต้าน" });
	        break;
	    case 6:
	        chart.addSeries({ name: "ระยะทางจากเพดาน" });
	        //chart.addSeries({ name: "อัตราเร็ว (v)" });	  
	        break;
	}
	/*switch (type) {
		case "beam0":
			chart.addSeries({name:"โมเมนต์ตาม"});
			chart.addSeries({name:"โมเมนต์ทวน"});
			chart.yAxis[0].axisTitle.attr({
				text: 'โมเมนต์'
			});
			chart.setTitle( { text: 'กราฟแสดงความสัมพันธ์ระหว่างโมเมนต์และเวลา (t)' }, { text: engtothaitype(selected.type)+" [ID: "+selected.id+"]" } );
			break;
		case "slide0":
			chart.addSeries({name:"อัตราเร็ว (V)"});
			chart.yAxis[0].axisTitle.attr({
				text: 'อัตราเร็ว [v] (เมตรต่อวินาที)'
			});
			chart.setTitle( { text: 'กราฟแสดงความสัมพันธ์ระหว่างอัตราเร็ว (v) และเวลา (t)' }, { text: "พื้นเอียง" } );
			break;
		case "slide1":
			chart.addSeries({name:"ระยะทางจากพื้น"});
			chart.yAxis[0].axisTitle.attr({
				text: 'ระยะทางจากพื้น (เมตร)'
			});
			chart.setTitle({ text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากพื้นและเวลา (t)' }, { text: "พื้นเอียง" });
			break;
		case "slide2":
			chart.addSeries({name:"ระยะทางจากจุดยอด"});
			chart.yAxis[0].axisTitle.attr({
				text: 'ระยะทางจากจุดยอด (เมตร)'
			});
			chart.setTitle({ text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากจุดยอดและเวลา (t)' }, { text: "พื้นเอียง" });
			break;
		case "wedge0":
			chart.addSeries({name:"ระยะทางที่เจาะลงไป"});
			chart.yAxis[0].axisTitle.attr({
				text: 'ระยะทางที่เจาะลงไป (เมตร)'
			});
			chart.setTitle( { text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางที่เจาะลงไปและเวลา (t)' }, { text: engtothaitype(selected.type)+" [ID: "+selected.id+"]" } );
			break;
		case "pulley0":
			chart.addSeries({name:"ระยะทางจากพื้น"});
			chart.yAxis[0].axisTitle.attr({
				text: 'ระยะทางจากพื้น (เมตร)'
			});
			chart.setTitle( { text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากพื้นและเวลา (t)' }, { text: engtothaitype(selected.type)+" [ID: "+selected.id+"]" } );
			break;
		case "pulley1":
			chart.addSeries({name:"เชือกด้านซ้าย"});
			chart.addSeries({name:"เชือกตรงกลาง"});
			chart.addSeries({name:"เชือกด้านขวา"});
			chart.yAxis[0].axisTitle.attr({
				text: 'ระยะทางจากรอกของเชือก (เมตร)'
			});
			chart.setTitle( { text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากรอกของเชือกและเวลา (t)' }, { text: engtothaitype(selected.type)+" [ID: "+selected.id+"]" } );
			break;
	    case "wheel0":
	        chart.addSeries({ name: "เชือกด้านนอก" });
	        chart.addSeries({ name: "เชือกด้านใน" });
	        chart.yAxis[0].axisTitle.attr({
	            text: 'ระยะทางจากล้อและเพลาของเชือก (เมตร)'
	        });
	        chart.setTitle({ text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากรอกของเชือกและเวลา (t)' }, { text: engtothaitype(selected.type) + " [ID: " + selected.id + "]" });
	        break;
	    case "ropewheel0":
	        chart.addSeries({ name: "ระยะทางจากล้อและเพลา" });
	        chart.yAxis[0].axisTitle.attr({
	            text: 'ระยะทางจากล้อและเพลา (เมตร)'
	        });
	        chart.setTitle({ text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากล้อและเพลาและเวลา (t)' }, { text: engtothaitype(selected.type) + " [ID: " + selected.id + "]" });
	        break;
		case "ropepulley0":
			chart.addSeries({name:"ระยะทางจากรอก"});
			chart.yAxis[0].axisTitle.attr({
				text: 'ระยะทางจากรอก (เมตร)'
			});
			chart.setTitle( { text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากรอกและเวลา (t)' }, { text: engtothaitype(selected.type)+" [ID: "+selected.id+"]" } );
			break;
		case "ropepulley1":case "ropewheel1":
			if (selected.up) {
				chart.addSeries({name:"ระยะทางจากเพดาน"});
				chart.yAxis[0].axisTitle.attr({
					text: 'ระยะทางจากเพดาน (เมตร)'
				});
				chart.setTitle( { text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากเพดานและเวลา (t)' }, { text: engtothaitype(selected.type)+" [ID: "+selected.id+"]" } );
				break;
			} else {
				chart.addSeries({name:"ระยะทางจากพื้น"});
				chart.yAxis[0].axisTitle.attr({
					text: 'ระยะทางจากพืน (เมตร)'
				});
				chart.setTitle( { text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากพื้นและเวลา (t)' }, { text: engtothaitype(selected.type)+" [ID: "+selected.id+"]" } );
				break;
			}
	    case "screw0":
	        chart.addSeries({ name: "ระยะทางจากเพดาน" });
	        chart.yAxis[0].axisTitle.attr({
	            text: 'ระยะทางจากพื้น (เมตร)'
	        });
	        chart.setTitle({ text: 'กราฟแสดงความสัมพันธ์ระหว่างระยะทางจากเพดานและเวลา (t)' }, { text: engtothaitype(selected.type) + " [ID: " + selected.id + "]" });
	        break;

	}*/
}

function slidenominus (i) {
	if (i < 0) {
		return 0;
	} else {
		return i;
	}
}

//var anit = 0;
var runstart = 0;

function run (test) {
	//beamrotate(objects[0],30);
	//var i = 0;
	//setInterval(function () {beamrotate(objects[0],i);i++;},100);
    var anit = 0;
    var plot = true;
    if (plot) {
        graphinit();
    }

	function aniend (endobj) {
		endobj.ani.active = false;
		endobj.ani.endt = t;
		end--;
	}
	
	function aniendsub (endobj,endobjroot) {
		endobj.ani.active = false;
		endobj.ani.endt = t;
		endobjroot.ani.end--;
	}
	
	if (onrun) {
		pause();
		return;
	}
	if (plot) {
	    $(".chartrun").button('option', 'label', 'หยุด');
	}
	onrun = true;
	if (!test) {
	    $(".runbutton div").css("background-image", "url(images/toptoolbar/pause.png)");
	    $(".runbutton").attr("title", "พักการจำลอง");
	    $(".runonly").css("opacity", "1");
	}
	clearanchor();
	//$(".norunonly").css("opacity","0.3");
	clearInterval(runfunc);
	
	var plottype = $("#chartdialog .starter .option").val();
	
	var end = objects.length;
	var t = 0.00;
	console.log("");

	$.each(objects,function (index,obj) {
		if (!obj.ani) {
			obj.ani = {};
		}
		//obj.ani.t = 0.00;
		obj.draggable(false);
		
		if ((!plot || (plot && (obj.id == selected[0].id || (selected[0].instanceof && obj.id == selected[0].instanceof.id)))) && obj.active) {
			
			if (obj.type != "object" && obj.type != "rope" && obj.type != "force") {
				obj.ani.active = true;
			} else {
				end--;
			}
			if (obj.type == "beam") {
				obj.getChildren()[0].draggable(false);
				obj.getChildren()[1].draggable(false);
				if (plot) {
					obj.ani.momentrplot = 0;
					obj.ani.momentlplot = 0;
				}
				obj.ani.a = 0;
				obj.ani.u = 0;

				obj.ani.a -= obj.momentr/pixel2m/((obj.xmax-(obj.xmax+obj.xmin)/2))*(180/Math.PI);
				obj.ani.a += obj.momentl/pixel2m/((obj.xmax-(obj.xmax+obj.xmin)/2))*(180/Math.PI);
				/*if (obj.weight > 0) {
					obj.ani.abase += g*(obj.fulcrum-(obj.xmax+obj.xmin)/2)/((obj.xmax-(obj.xmax+obj.xmin)/2))*(180/Math.PI);
				}*/
				//obj.ani.a = obj.ani.abase;
				//obj.ani.a = -(obj.momentr-obj.momentl)/(w/1000);
				/*if (obj.momentr > obj.momentl) {
					obj.ani.onesec = -(obj.momentr/obj.momentl);
				} else {
					obj.ani.onesec = obj.momentl/obj.momentr;
				}
				if (!isFinite(obj.ani.onesec)) {
					obj.ani.onesec = (obj.ani.onesec<0)?-360:360;
				} else if (obj.ani.a == 1) {
					obj.ani.onesec = 0;
				}
				obj.ani.a = obj.ani.onesec/0.5;*/
				obj.ani.angle = 0;
				/*$.each(obj.objects,function(index,obj2) {
					if (obj2.centerori > obj.fulcrum) {
						obj.ani.momentr = obj.ani.momentr+(obj2.weight*(obj2.center-obj.fulcrum));
					} else {
						obj.ani.momentl = obj.ani.momentl+(obj2.weight*(obj.fulcrum-obj2.center));
					}
				});*/
				if (obj.momentr>obj.momentl) {
					obj.ani.momenttype = "ge";
				} else if (obj.momentr==obj.momentl) {
					obj.ani.momenttype = "eq";
				} else {
					obj.ani.momenttype = "le";
				}

			} else if (obj.type == "slide") {
				obj.getChildren()[0].draggable(false);
				obj.ani.end = obj.objects.length;
				$.each(obj.objects,function(index,obj2) {
					obj2.ani = {};
					//obj2.ani.totalf = 0;
					var totalf = 0;
					$.each(obj2.forces, function (index, f) {
					    var up = f.up;
					    if (f.reverse) { up = !f.up; }
						if (up) {
							//obj2.ani.totalf += f.force;
							totalf += f.force;
						} else {
							//obj2.ani.totalf -= f.force;
							totalf -= f.force;
						}
					});
					
					console.log(obj2.ani.totalf);
					
					obj2.ani.active = true;
					obj2.ani.dori = obj2.ani.d = obj2.dfromend;
					obj2.ani.dcurr = 0;
					obj2.ani.a = (/*slidenominus*/((obj2.weight/1000*g)*(Math.sin(obj.angle*Math.PI/180)-obj.u*Math.cos(obj.angle*Math.PI/180)))-totalf)/(obj2.weight/1000)/pixel2m;
					//console.log(obj2.ani.a);
					if (obj2.ani.a == 0) {
						aniendsub(obj2,obj);
					}
					//obj2.ani.a = 1000;
					//console.log((Math.sin(obj.angle)-Math.cos(obj.angle))+" "+obj2.ani.a+" "+obj.angle);
					//console.log(obj.objects[0].ani);
				});
				obj.ani.slided = Math.linear.getPointDistance(obj.xstart, obj.ystart, obj.xend, stageh - 60, true);
				if (obj.ani.end == 0) {
					aniend(obj);
				}
			} else if (obj.type == "wedge") {
				obj.getChildren()[0].draggable(false);
				obj.moveToTop();
				var totalf = obj.weight/1000*g;
				$.each(obj.objects,function (index,obj2) {
					totalf += obj2.weight/1000*g;
					obj2.moveToTop();
				});
				$.each(obj.forces,function (index,f) {
					totalf += f.force*Math.cos(f.angle*(Math.PI/180));
					f.moveToTop();
				});
				
				if (totalf == 0) {
					aniend(obj);
				} else {
					//obj.ani.h = obj.w*obj.width*pixel2m/totalf;
					obj.ani.u = totalf*obj.height*pixel2m/obj.weight;
					obj.ani.a = obj.w*obj.width*pixel2m/obj.weight;
				}
				
				if (plot) {
				    obj.ani.splot = 0;
				    obj.ani.vplot = 0;
				}
				//obj.ani.endt = Math.quadratic(-(1/2*obj.ani.a),obj.ani.u,obj.ani.h*pixel2m)[1];
				//obj.ani.s = 0;
				//console.log(obj.ani.u+" "+obj.ani.a);
				//console.log(obj.ani.t);
			} else if (obj.type == "wheel") {
				if (plot) {
					obj.ani.outeryarray = {};
					obj.ani.inneryarray = {};
				}
				
				var ef = 0;
				$.each(obj.outerrope.objects,function (index,obj2) {
					ef += obj2.weight/1000*g;
					//leftw += obj2.weight;
				});
				$.each(obj.outerrope.forces,function (index,obj2) {
					ef += obj2.force;
				});
				var wf = 0;
				var ww = 0;
				$.each(obj.innerrope.objects,function (index,obj2) {
					wf += obj2.weight/1000*g;
					ww += obj2.weight/1000;
				});
				$.each(obj.innerrope.forces,function (index,obj2) {
					wf += obj2.force;
				});
				
				var wbalance = ef*obj.r/obj.rinner;
				obj.ani.a = (wbalance - wf) / ww;

				if (ww == 0) {
				    aniend(obj);
				}
			
			} else if (obj.type == "pulley") {
				if (plot) {
					obj.ani.leftyplot = 0;
					obj.ani.rightyplot = 0;
					obj.ani.middleyplot = 0;
					obj.ani.yplot = 0;
				}
				
				switch (obj.pulleytype) {
					case 0:case 1:
						var leftf = 0;
						var leftw = 0;
						var rightf = 0;
						var rightw = 0;
						$.each(obj.leftrope.objects,function (index,obj2) {
							leftf += obj2.weight/1000*g;
							leftw += obj2.weight/1000;
						});
						$.each(obj.leftrope.forces,function (index,obj2) {
							leftf += obj2.force;
						});
						$.each(obj.rightrope.objects,function (index,obj2) {
							rightf += obj2.weight/1000*g;
							rightw += obj2.weight/1000;
						});
						$.each(obj.rightrope.forces,function (index,obj2) {
							rightf += obj2.force;
						});
						obj.ani.f = Math.abs(leftf-rightf);
						obj.ani.a = obj.ani.f/(leftw+rightw+obj.leftrope.weight);
						if (leftf > rightf) {
							obj.ani.leftwin = true;
							//obj.ani.a = obj.ani.f/leftf;
						} else {
							obj.ani.rightwin = true;
							//obj.ani.a = obj.ani.f/rightf;
						}
						
						//console.log(leftf);
						//console.log(rightf);
						
						if (obj.ani.a == 0 || leftw + rightw == 0) {
							aniend(obj);
						}
						break;
					case 2:case 4:
						var middlef = 0;
						var middlew = 0;
						var rightf = 0;
						var rightw = 0;
						$.each(obj.middlerope.objects,function (index,obj2) {
							middlef += obj2.weight/1000*g;
							middlew += obj2.weight/1000;
						});
						$.each(obj.middlerope.forces,function (index,obj2) {
							middlef += obj2.force;
						});
						$.each(obj.rightrope.objects,function (index,obj2) {
							rightf += obj2.weight/1000*g;
							rightw += obj2.weight/1000;
						});
						$.each(obj.rightrope.forces,function (index,obj2) {
							rightf += obj2.force;
						});
						obj.ani.f = rightf-middlef/2;
						if (obj.ani.f == 0 || middlef == 0) {
							aniend(obj);
						} else {
							obj.ani.a = obj.ani.f/(middlew/2+obj.rightrope.weight);
						}
						break;
					case 3:case 5:
						var middlef = 0;
						var middlew = 0;
						var rightf = 0;
						var rightw = 0;
						$.each(obj.middlerope.objects,function (index,obj2) {
							middlef += obj2.weight/1000*g;
							middlew += obj2.weight/1000;
						});
						$.each(obj.middlerope.forces,function (index,obj2) {
							middlef += obj2.force;
						});
						$.each(obj.leftrope.objects,function (index,obj2) {
							rightf += obj2.weight/1000*g;
							rightw += obj2.weight/1000;
						});
						$.each(obj.leftrope.forces,function (index,obj2) {
							rightf += obj2.force;
						});
						obj.ani.f = rightf-middlef/2;
						if (obj.ani.f == 0 || middlef == 0) {
							aniend(obj);
						} else {
							obj.ani.a = obj.ani.f/(middlew/2+obj.leftrope.weight);
						}
						break;
				}
			} else if (obj.type == "screw") {
			    var totalw = 0;
                
			    obj.ani.minymin = obj.y;
			    $.each(obj.objects, function (index, obj2) {
			        totalw += obj2.weight;
			        if (obj2.ymin < obj.ani.minymin) {
			            obj.ani.minymin = obj2.ymin;
			        }
			    });

			    var ebalance = ((totalw / 1000 * g) * obj.h) / (2 * Math.PI * obj.handd);
			    var ewin = obj.e - ebalance;

			    if (ewin <= 0 || totalw == 0) {
			        aniend(obj);
			    }

			    obj.ani.h1sec = (ewin * 2 * Math.PI * obj.handd) / (totalw / 1000 * g);
			    obj.ani.s = 0;
			    if (plot) {
			        obj.ani.sarray = {};
			    }
			}
		} else {
			end--;
		}
	});
	runstart = performance.now();
	function ani() { try { if (!runpause) {
	    $.each(objects, function (index, obj) {
	        if ((!plot || (plot && (obj.id == selected[0].id || (selected[0].instanceof && obj.id == selected[0].instanceof.id)))) && obj.ani.active && obj.active) {
	            if (obj.type == "beam") {
	                console.log(obj.ani.angle);
	                obj.ani.angle += obj.ani.u*(t-anit)+1/2*obj.ani.a*(t-anit)*(t-anit);
	                obj.ani.u += obj.ani.a*(t-anit);
	                if (beamrotate(obj,obj.ani.angle) == false) {
	                    aniend(obj);
	                }
	                obj.ani.momentr = 0;obj.ani.momentl = 0;
	                var moment = calmoment(obj);
	                /*$.each(obj.objects,function(index,obj2) {
						if (obj2.centerori > obj.fulcrum) {
							obj.ani.momentr = obj.ani.momentr+((obj2.weight/1000*g)*(obj2.center-obj.fulcrum)*pixel2m);
						} else {
							obj.ani.momentl = obj.ani.momentl+((obj2.weight/1000*g)*(obj.fulcrum-obj2.center)*pixel2m);
						}
					});*/
	                obj.ani.momentr = moment.momentr;
	                obj.ani.momentl = moment.momentl;
	                if (plot) {
	                    obj.ani.momentrplot = moment.momentr;
	                    obj.ani.momentlplot = moment.momentl;
	                }
					
	                //console.log(obj.ani.angle);
					
	                obj.ani.abefore = obj.ani.a;
					
	                if (moment.momentr >= 0.00001 || moment.momentl >= 0.00001) {
	                    obj.ani.a = 0;
	                    obj.ani.a -= obj.ani.momentr/pixel2m/((obj.xmax-(obj.xmax+obj.xmin)/2))*(180/Math.PI);
	                    obj.ani.a += obj.ani.momentl/pixel2m/((obj.xmax-(obj.xmax+obj.xmin)/2))*(180/Math.PI);
						
	                } else {
	                    beamrotate(obj, (obj.ani.angle > 0) ? 90 : -90);
	                    if (plot) {
	                        obj.ani.momentrplot = 0;
	                        obj.ani.momentlplot = 0;
	                    }
	                    aniend(obj);
	                }
	                plotgraph(0, obj.ani.momentrplot, t);
	                plotgraph(1, obj.ani.momentlplot, t);
	                //console.log(obj.ani.momentr);
	                //console.log(Math.floor(obj.ani.momentr)+" "+Math.floor(obj.ani.momentl));
	                /*if ((obj.ani.momenttype == "ge" && obj.ani.momentr < obj.ani.momentl) || (obj.ani.momenttype == "eq") || (obj.ani.momenttype == "le" && obj.ani.momentr > obj.ani.momentl)) {
						aniend(obj);
					}*/
	                //if (!plot) {
	                updatestatus();
	                //}

	            } else if (obj.type == "slide") {
	                $.each(obj.objects,function(index,obj2) {
	                    if (obj2.ani.active) {
	                        obj2.ani.dcurr = 1/2*obj2.ani.a*t*t;
	                        obj2.ani.dnew = obj2.ani.d-obj2.ani.dcurr;
	                        if (obj2.ani.dnew-Math.abs(obj2.width/2)-3 >= 0) {
	                            setobjectslidepos(obj2, obj2.ani.dnew);
	                        } else {
	                            setobjectslidepos(obj2,Math.abs(obj2.width/2)-3);
	                            aniendsub(obj2,obj);
	                        }
	                        if (obj2.ani.dnew + Math.abs(obj2.width / 2) + 3 >= obj.ani.slided) {
	                            console.log(t);
	                            setobjectslidepos(obj2, obj.ani.slided - Math.abs(obj2.width / 2));
	                            aniendsub(obj2, obj);
	                        }
	                        plotgraph(0, -(obj2.ani.a * t) * pixel2m, t);
	                        plotgraph(1, (obj2.ani.dnew - Math.abs(obj2.width / 2)) * pixel2m, t);
	                        plotgraph(2, (obj.ani.slided - Math.abs(obj2.width / 2) - obj2.ani.dnew) * pixel2m, t);
	                    }
	                });
	                //console.log(obj.ani.end);
	                if (obj.ani.end == 0) {
	                    aniend(obj);
	                }
	            } else if (obj.type == "wedge") {
	                //console.log(1/2*obj.ani.a*t*t);
	                var s = obj.ani.u*t-1/2*obj.ani.a*t*t;
	                var splus = s/pixel2m;
	                if (obj.ani.u-obj.ani.a*t >= 0) {
	                    obj.getChildren()[0].points([obj.xstart,obj.ystart+splus,obj.xend,obj.ystart+splus,(obj.xstart+obj.xend)/2,stageh-63+splus]);
	                    obj.draw();
	                    $.each(obj.objects,function(index,obj2) {
	                        obj2.getChildren()[0].points([obj2.xmin, obj2.ymin+splus, obj2.xmin, obj2.ymax+splus, obj2.xmax, obj2.ymax+splus, obj2.xmax, obj2.ymin+splus]);
	                        obj2.draw();
	                    });
	                    $.each(obj.forces,function(index,f) {
	                        f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+splus,f.xend,f.yend+splus,true));
	                        f.draw();
	                    });
	                } else {
	                    aniend(obj);
	                }
	                plotgraph(0, s, t);
	                plotgraph(1, obj.ani.u - obj.ani.a * t, t);

	            } else if (obj.type == "wheel") {
	                var s = 1/2*obj.ani.a*t*t;
	                var outerrope = obj.outerrope;
	                var innerrope = obj.innerrope;
	                outerrope.getChildren()[0].points([outerrope.xstart,outerrope.ystart,outerrope.xend,outerrope.yend+s/pixel2m]);
	                $.each(outerrope.objects,function (index,obj2) {
	                    if (obj2.ymax+s/pixel2m >= stageh-60) {
	                        aniend(obj);
	                        obj2.getChildren()[0].points([obj2.xmin, stageh-60-obj2.height, obj2.xmin, stageh-60, obj2.xmax, stageh-60, obj2.xmax, stageh-60-obj2.height]);
	                    } else {
	                        obj2.getChildren()[0].points([obj2.xmin, obj2.ymin+s/pixel2m, obj2.xmin, obj2.ymax+s/pixel2m, obj2.xmax, obj2.ymax+s/pixel2m, obj2.xmax, obj2.ymin+s/pixel2m]);
	                    }
	                    obj2.draw();
	                });
	                $.each(outerrope.forces,function (index,f) {
	                    if (outerrope.yend+s/pixel2m >= stageh-60) {
	                        f.getChildren()[0].points(arrowpoint(f.xstart,stageh-60,f.xend,stageh-60+f.d,false));
	                    } else {
	                        f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+s/pixel2m,f.xend,f.yend+s/pixel2m,false));
	                    }
	                    f.draw();
	                });
	                if (outerrope.yend+s/pixel2m >= stageh-60) {
	                    outerrope.getChildren()[0].points([outerrope.xstart,outerrope.ystart,outerrope.xend,stageh-60]);
	                    aniend(obj);
	                }
	                outerrope.draw();
	                if (outerrope.yend+s/pixel2m <= obj.center.y) {
	                    outerrope.getChildren()[0].points([outerrope.xstart,outerrope.ystart,outerrope.xend,outerrope.ystart]);
	                    outerrope.draw();
	                    aniend(obj);
	                }
	                innerrope.getChildren()[0].points([innerrope.xstart,innerrope.ystart,innerrope.xend,innerrope.yend-s/pixel2m]);
	                $.each(innerrope.objects,function (index,obj2) {
	                    obj2.getChildren()[0].points([obj2.xmin, obj2.ymin-s/pixel2m, obj2.xmin, obj2.ymax-s/pixel2m, obj2.xmax, obj2.ymax-s/pixel2m, obj2.xmax, obj2.ymin-s/pixel2m]);
	                    obj2.draw();
	                });
	                $.each(innerrope.forces,function (index,f) {
	                    f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart-s/pixel2m,f.xend,f.yend-s/pixel2m,false));
	                    f.draw();
	                });
	                if (innerrope.yend-s/pixel2m >= stageh-60) {
	                    innerrope.getChildren()[0].points([innerrope.xstart,innerrope.ystart,innerrope.xend,stageh-60]);
	                    aniend(obj);
	                }
	                innerrope.draw();
	                if (innerrope.yend-s/pixel2m <= obj.center.y) {
	                    innerrope.getChildren()[0].points([innerrope.xstart,innerrope.ystart,innerrope.xend,innerrope.ystart]);
	                    innerrope.draw();
	                    aniend(obj);
	                }
					
	                /*if (plot) {
	                    obj.ani.outeryarray[t] = outerrope.getChildren()[0].points()[3];
	                    obj.ani.inneryarray[t] = innerrope.getChildren()[0].points()[3];
	                }*/
	                plotgraph(0, (outerrope.getChildren()[0].points()[3] - obj.center.y) * pixel2m, t);
	                plotgraph(1, (innerrope.getChildren()[0].points()[3] - obj.center.y) * pixel2m, t);
	            } else if (obj.type == "pulley") {
	                var s = 1/2*obj.ani.a*t*t;
	                var leftrope = obj.leftrope;
	                var rightrope = obj.rightrope;
	                var middlerope = obj.middlerope;
	                switch (obj.pulleytype) {
	                    case 0:
	                        if (obj.ani.leftwin) {
	                            //var floorend = false;
	                            leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart,leftrope.xend,leftrope.yend+s/pixel2m]);
	                            $.each(leftrope.objects,function (index,obj2) {
	                                if (obj2.ymax+s/pixel2m >= stageh-60) {
	                                    aniend(obj);
	                                    obj2.getChildren()[0].points([obj2.xmin, stageh-60-obj2.height, obj2.xmin, stageh-60, obj2.xmax, stageh-60, obj2.xmax, stageh-60-obj2.height]);
	                                } else {
	                                    obj2.getChildren()[0].points([obj2.xmin, obj2.ymin+s/pixel2m, obj2.xmin, obj2.ymax+s/pixel2m, obj2.xmax, obj2.ymax+s/pixel2m, obj2.xmax, obj2.ymin+s/pixel2m]);
	                                }
	                                obj2.draw();
	                            });
	                            $.each(leftrope.forces,function (index,f) {
	                                if (leftrope.yend+s/pixel2m >= stageh-60) {
	                                    f.getChildren()[0].points(arrowpoint(f.xstart,stageh-60,f.xend,stageh-60+f.d,false));
	                                } else {
	                                    f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+s/pixel2m,f.xend,f.yend+s/pixel2m,false));
	                                }
	                                f.draw();
	                            });
	                            if (leftrope.yend+s/pixel2m >= stageh-60) {
	                                leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart,leftrope.xend,stageh-60]);
	                                aniend(obj);
	                            }
	                            leftrope.draw();
	                            rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart,rightrope.xend,rightrope.yend-s/pixel2m]);
	                            $.each(rightrope.objects,function (index,obj2) {
	                                obj2.getChildren()[0].points([obj2.xmin, obj2.ymin-s/pixel2m, obj2.xmin, obj2.ymax-s/pixel2m, obj2.xmax, obj2.ymax-s/pixel2m, obj2.xmax, obj2.ymin-s/pixel2m]);
	                                obj2.draw();
	                            });
	                            $.each(rightrope.forces,function (index,f) {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart-s/pixel2m,f.xend,f.yend-s/pixel2m,false));
	                                f.draw();
	                            });
	                            rightrope.draw();
	                            if (rightrope.yend-s/pixel2m <= obj.center.y) {
	                                rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart,rightrope.xend,rightrope.ystart]);
	                                rightrope.draw();
	                                aniend(obj);
	                            }
	                        } else {
	                            rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart,rightrope.xend,rightrope.yend+s/pixel2m]);
	                            $.each(rightrope.objects,function (index,obj2) {
	                                if (obj2.ymax+s/pixel2m >= stageh-60) {
	                                    aniend(obj);
	                                    obj2.getChildren()[0].points([obj2.xmin, stageh-60-obj2.height, obj2.xmin, stageh-60, obj2.xmax, stageh-60, obj2.xmax, stageh-60-obj2.height]);
	                                } else {
	                                    obj2.getChildren()[0].points([obj2.xmin, obj2.ymin+s/pixel2m, obj2.xmin, obj2.ymax+s/pixel2m, obj2.xmax, obj2.ymax+s/pixel2m, obj2.xmax, obj2.ymin+s/pixel2m]);
	                                }
	                                obj2.draw();
	                            });
	                            $.each(rightrope.forces,function (index,f) {
	                                if (rightrope.yend+s/pixel2m >= stageh-60) {
	                                    f.getChildren()[0].points(arrowpoint(f.xstart,stageh-60,f.xend,stageh-60+f.d,false));
	                                } else {
	                                    f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+s/pixel2m,f.xend,f.yend+s/pixel2m,false));
	                                }
	                                f.draw();
	                            });
	                            if (rightrope.yend+s/pixel2m >= stageh-60) {
	                                rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart,rightrope.xend,stageh-60]);
	                                aniend(obj);
	                            }
	                            rightrope.draw();
	                            leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart,leftrope.xend,leftrope.yend-s/pixel2m]);
	                            $.each(leftrope.objects,function (index,obj2) {
	                                obj2.getChildren()[0].points([obj2.xmin, obj2.ymin-s/pixel2m, obj2.xmin, obj2.ymax-s/pixel2m, obj2.xmax, obj2.ymax-s/pixel2m, obj2.xmax, obj2.ymin-s/pixel2m]);
	                                obj2.draw();
	                            });
	                            $.each(leftrope.forces,function (index,f) {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart-s/pixel2m,f.xend,f.yend-s/pixel2m,false));
	                                f.draw();
	                            });
	                            leftrope.draw();
	                            if (leftrope.yend-s/pixel2m <= obj.center.y) {
	                                leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart,leftrope.xend,leftrope.ystart]);
	                                leftrope.draw();
	                                aniend(obj);
	                            }
	                        }
	                        //console.log("aaa");
	                        break;
	                    case 1:
	                        if (obj.ani.leftwin) {
	                            //var floorend = false;
	                            leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart,leftrope.xend,leftrope.yend-s/pixel2m]);
	                            $.each(leftrope.forces,function (index,f) {
	                                if (leftrope.yend-s/pixel2m <= 40) {
	                                    f.getChildren()[0].points(arrowpoint(f.xstart,40,f.xend,40-f.d,false));
	                                } else {
	                                    f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart-s/pixel2m,f.xend,f.yend-s/pixel2m,false));
	                                }
	                                f.draw();
	                            });
	                            if (leftrope.yend-s/pixel2m <= 40) {
	                                leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart,leftrope.xend,40]);
	                                aniend(obj);
	                            }
	                            leftrope.draw();
	                            rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart,rightrope.xend,rightrope.yend+s/pixel2m]);
	                            $.each(rightrope.forces,function (index,f) {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+s/pixel2m,f.xend,f.yend+s/pixel2m,false));
	                                f.draw();
	                            });
	                            rightrope.draw();
	                            if (rightrope.yend+s/pixel2m >= obj.center.y) {
	                                rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart,rightrope.xend,rightrope.ystart]);
	                                rightrope.draw();
	                                aniend(obj);
	                            }
								
	                        } else {
	                            rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart,rightrope.xend,rightrope.yend-s/pixel2m]);
	                            $.each(rightrope.forces,function (index,f) {
	                                if (rightrope.yend-s/pixel2m <= 40) {
	                                    f.getChildren()[0].points(arrowpoint(f.xstart,40,f.xend,40-f.d,false));
	                                } else {
	                                    f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart-s/pixel2m,f.xend,f.yend-s/pixel2m,false));
	                                }
	                                f.draw();
	                            });
	                            if (rightrope.yend-s/pixel2m <= 40) {
	                                rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart,rightrope.xend,40]);
	                                aniend(obj);
	                            }
	                            rightrope.draw();
	                            leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart,leftrope.xend,leftrope.yend+s/pixel2m]);
	                            $.each(leftrope.objects,function (index,obj2) {
	                                obj2.getChildren()[0].points([obj2.xmin, obj2.ymin+s/pixel2m, obj2.xmin, obj2.ymax+s/pixel2m, obj2.xmax, obj2.ymax+s/pixel2m, obj2.xmax, obj2.ymin+s/pixel2m]);
	                                obj2.draw();
	                            });
	                            $.each(leftrope.forces,function (index,f) {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+s/pixel2m,f.xend,f.yend+s/pixel2m,false));
	                                f.draw();
	                            });
	                            leftrope.draw();
	                            if (leftrope.yend+s/pixel2m >= obj.center.y) {
	                                leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart,leftrope.xend,leftrope.ystart]);
	                                leftrope.draw();
	                                aniend(obj);
	                            }
	                        }
	                        break;
	                    case 2:
	                        rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart-s/pixel2m,rightrope.xend,rightrope.yend-s/pixel2m*2]);
	                        $.each(rightrope.forces,function (index,f) {
	                            if (rightrope.yend-s/pixel2m*2 <= 40) {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,40,f.xend,40-f.d,false));
	                            } else {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart-s/pixel2m*2,f.xend,f.yend-s/pixel2m*2,false));
	                            }
	                            f.draw();
	                        });
	                        if (rightrope.yend - s / pixel2m * 2 <= 40) {
	                            rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart-s/pixel2m,rightrope.xend,40]);
	                            aniend(obj);
	                        }
	                        if (rightrope.yend - s / pixel2m * 2 >= obj.center.y) {
	                            rightrope.getChildren()[0].points([rightrope.xstart, rightrope.ystart, rightrope.xend, rightrope.ystart]);
	                            aniend(obj);
	                        }
	                        rightrope.draw();
	                        middlerope.getChildren()[0].points([middlerope.xstart,middlerope.ystart-s/pixel2m,middlerope.xend,middlerope.yend-s/pixel2m]);
	                        $.each(middlerope.objects, function (index, obj2) {
	                            if (obj2.ymax - s / pixel2m >= stageh - 60) {
	                                aniend(obj);
	                                obj2.getChildren()[0].points([obj2.xmin, stageh - 60 - obj2.height, obj2.xmin, stageh - 60, obj2.xmax, stageh - 60, obj2.xmax, stageh - 60 - obj2.height]);
	                            } else {
	                                obj2.getChildren()[0].points([obj2.xmin, obj2.ymin - s / pixel2m, obj2.xmin, obj2.ymax - s / pixel2m, obj2.xmax, obj2.ymax - s / pixel2m, obj2.xmax, obj2.ymin - s / pixel2m]);
	                            }
	                            obj2.draw();
	                        });
	                        $.each(middlerope.forces,function (index,f) {
	                            f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart-s/pixel2m,f.xend,f.yend-s/pixel2m,false));
	                            f.draw();
	                        });
	                        middlerope.draw();
	                        leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart-s/pixel2m,leftrope.xend,leftrope.yend]);
	                        leftrope.draw();
	                        obj.setAbsolutePosition({x:0,y:-s/pixel2m});
	                        obj.draw();
	                        break;
	                    case 3:
	                        leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart-s/pixel2m,leftrope.xend,leftrope.yend-s/pixel2m*2]);
	                        $.each(leftrope.forces,function (index,f) {
	                            if (leftrope.yend-s/pixel2m*2 <= 40) {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,40,f.xend,40-f.d,false));
	                            } else {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart-s/pixel2m*2,f.xend,f.yend-s/pixel2m*2,false));
	                            }
	                            f.draw();
	                        });
	                        if (leftrope.yend-s/pixel2m*2 <= 40) {
	                            leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart-s/pixel2m,leftrope.xend,40]);
	                            aniend(obj);
	                        }
	                        if (leftrope.yend - s / pixel2m * 2 >= obj.center.y) {
	                            rightrope.getChildren()[0].points([rightrope.xstart, rightrope.ystart, rightrope.xend, rightrope.ystart]);
	                            aniend(obj);
	                        }
	                        leftrope.draw();
	                        middlerope.getChildren()[0].points([middlerope.xstart,middlerope.ystart-s/pixel2m,middlerope.xend,middlerope.yend-s/pixel2m]);
	                        $.each(middlerope.objects, function (index, obj2) {
	                            if (obj2.ymax - s / pixel2m >= stageh - 60) {
	                                aniend(obj);
	                                obj2.getChildren()[0].points([obj2.xmin, stageh - 60 - obj2.height, obj2.xmin, stageh - 60, obj2.xmax, stageh - 60, obj2.xmax, stageh - 60 - obj2.height]);
	                            } else {
	                                obj2.getChildren()[0].points([obj2.xmin, obj2.ymin - s / pixel2m, obj2.xmin, obj2.ymax - s / pixel2m, obj2.xmax, obj2.ymax - s / pixel2m, obj2.xmax, obj2.ymin - s / pixel2m]);
	                            }
	                            obj2.draw();
	                        });
	                        $.each(middlerope.forces,function (index,f) {
	                            f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart-s/pixel2m,f.xend,f.yend-s/pixel2m,false));
	                            f.draw();
	                        });
	                        middlerope.draw();
	                        rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart-s/pixel2m,rightrope.xend,rightrope.yend]);
	                        rightrope.draw();
	                        obj.setAbsolutePosition({x:0,y:-s/pixel2m});
	                        obj.draw();
	                        break;
	                    case 4:
	                        rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart+s/pixel2m,rightrope.xend,rightrope.yend+s/pixel2m*2]);
	                        $.each(rightrope.objects,function (index,obj2) {
	                            if (obj2.ymax+s/pixel2m*2 >= stageh-60) {
	                                aniend(obj);
	                                obj2.getChildren()[0].points([obj2.xmin, stageh-60-obj2.height, obj2.xmin, stageh-60, obj2.xmax, stageh-60, obj2.xmax, stageh-60-obj2.height]);
	                            } else {
	                                obj2.getChildren()[0].points([obj2.xmin, obj2.ymin+s/pixel2m*2, obj2.xmin, obj2.ymax+s/pixel2m*2, obj2.xmax, obj2.ymax+s/pixel2m*2, obj2.xmax, obj2.ymin+s/pixel2m*2]);
	                            }
	                            obj2.draw();
	                        });
	                        $.each(rightrope.forces,function (index,f) {
	                            if (rightrope.yend+s/pixel2m*2 >= stageh-60) {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,stageh-60,f.xend,stageh-60+f.d,false));
	                            } else {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+s/pixel2m*2,f.xend,f.yend+s/pixel2m*2,false));
	                            }
	                            f.draw();
	                        });
	                        if (rightrope.yend+s/pixel2m*2 >= stageh-60) {
	                            rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart+s/pixel2m,rightrope.xend,stageh-60]);
	                            aniend(obj);
	                        }
	                        /*if (rightrope.yend + s / pixel2m * 2 >= obj.center.y) {
							    rightrope.getChildren()[0].points([rightrope.xstart, rightrope.ystart, rightrope.xend, rightrope.ystart]);
							    aniend(obj);
							}*/
	                        rightrope.draw();
	                        middlerope.getChildren()[0].points([middlerope.xstart,middlerope.ystart+s/pixel2m,middlerope.xend,middlerope.yend+s/pixel2m]);
	                        $.each(middlerope.objects, function (index, obj2) {
	                            /*if (obj2.ymax + s / pixel2m >= stageh - 60) {
							        aniend(obj);
							        obj2.getChildren()[0].points([obj2.xmin, stageh - 60 - obj2.height, obj2.xmin, stageh - 60, obj2.xmax, stageh - 60, obj2.xmax, stageh - 60 - obj2.height]);
							    } else {*/
	                            obj2.getChildren()[0].points([obj2.xmin, obj2.ymin + s / pixel2m, obj2.xmin, obj2.ymax + s / pixel2m, obj2.xmax, obj2.ymax + s / pixel2m, obj2.xmax, obj2.ymin - s / pixel2m]);
	                            //}
	                            obj2.draw();
	                        });
	                        $.each(middlerope.forces,function (index,f) {
	                            f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+s/pixel2m,f.xend,f.yend+s/pixel2m,false));
	                            f.draw();
	                        });
	                        middlerope.draw();
	                        leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart+s/pixel2m,leftrope.xend,leftrope.yend]);
	                        leftrope.draw();
	                        obj.setAbsolutePosition({x:0,y:s/pixel2m});
	                        obj.draw();
	                        break;
	                    case 5:
	                        leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart+s/pixel2m,leftrope.xend,leftrope.yend+s/pixel2m*2]);
	                        $.each(leftrope.objects,function (index,obj2) {
	                            if (obj2.ymax+s/pixel2m*2 >= stageh-60) {
	                                aniend(obj);
	                                obj2.getChildren()[0].points([obj2.xmin, stageh-60-obj2.height, obj2.xmin, stageh-60, obj2.xmax, stageh-60, obj2.xmax, stageh-60-obj2.height]);
	                            } else {
	                                obj2.getChildren()[0].points([obj2.xmin, obj2.ymin+s/pixel2m*2, obj2.xmin, obj2.ymax+s/pixel2m*2, obj2.xmax, obj2.ymax+s/pixel2m*2, obj2.xmax, obj2.ymin+s/pixel2m*2]);
	                            }
	                            obj2.draw();
	                        });
	                        $.each(leftrope.forces,function (index,f) {
	                            if (leftrope.yend+s/pixel2m*2 >= stageh-60) {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,stageh-60,f.xend,stageh-60+f.d,false));
	                            } else {
	                                f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+s/pixel2m*2,f.xend,f.yend+s/pixel2m*2,false));
	                            }
	                            f.draw();
	                        });
	                        if (leftrope.yend+s/pixel2m*2 >= stageh-60) {
	                            leftrope.getChildren()[0].points([leftrope.xstart,leftrope.ystart+s/pixel2m,leftrope.xend,stageh-60]);
	                            aniend(obj);
	                        }
	                        leftrope.draw();
	                        middlerope.getChildren()[0].points([middlerope.xstart,middlerope.ystart+s/pixel2m,middlerope.xend,middlerope.yend+s/pixel2m]);
	                        $.each(middlerope.objects, function (index, obj2) {
	                            /*if (obj2.ymax - s / pixel2m >= stageh - 60) {
							        aniend(obj);
							        obj2.getChildren()[0].points([obj2.xmin, stageh - 60 - obj2.height, obj2.xmin, stageh - 60, obj2.xmax, stageh - 60, obj2.xmax, stageh - 60 - obj2.height]);
							    } else {*/
	                            obj2.getChildren()[0].points([obj2.xmin, obj2.ymin + s / pixel2m, obj2.xmin, obj2.ymax + s / pixel2m, obj2.xmax, obj2.ymax + s / pixel2m, obj2.xmax, obj2.ymin - s / pixel2m]);
	                            //}
	                            obj2.draw();
	                        });
	                        $.each(middlerope.forces,function (index,f) {
	                            f.getChildren()[0].points(arrowpoint(f.xstart,f.ystart+s/pixel2m,f.xend,f.yend+s/pixel2m,false));
	                            f.draw();
	                        });
	                        middlerope.draw();
	                        rightrope.getChildren()[0].points([rightrope.xstart,rightrope.ystart+s/pixel2m,rightrope.xend,rightrope.yend]);
	                        rightrope.draw();
	                        obj.setAbsolutePosition({x:0,y:s/pixel2m});
	                        obj.draw();
	                        break;
	                }
	                if (plot) {
	                    obj.ani.leftyplot = leftrope.getChildren()[0].points()[3];
	                    obj.ani.rightyplot = rightrope.getChildren()[0].points()[3];
	                    obj.ani.middleyplot = middlerope.getChildren()[0].points()[3];
	                    obj.ani.yplot = obj.getChildren()[0].getY() + obj.getAbsolutePosition().y;
	                    plotgraph(0, Math.abs(obj.ani.leftyplot - obj.ani.yplot) * pixel2m, t);
	                    if (obj.middlerope.up) {
	                        plotgraph(1, Math.abs(obj.ani.middleyplot - (obj.ani.yplot - obj.r)) * pixel2m, t);
	                    } else {
	                        plotgraph(1, Math.abs(obj.ani.middleyplot - (obj.ani.yplot + obj.r)) * pixel2m, t);
	                    }
	                    plotgraph(2, Math.abs(obj.ani.rightyplot - obj.ani.yplot) * pixel2m, t);
	                    plotgraph(3, (stageh - 60 - obj.ani.yplot) * pixel2m, t);
	                    //console.log(obj.ani.yarray[t]);
	                }
	                //console.log(end);
	            } else if (obj.type == "screw") {
	                obj.ani.s += obj.ani.h1sec * (t - anit);

	                screwani(obj, obj.ani.s);

	                if (obj.ani.minymin - obj.ani.s <= 40) {
	                    screwani(obj, stageh - 110 - (stageh - 70 - obj.ani.minymin));
	                    aniend(obj);
	                }
	                if (stageh - 100 - obj.ani.s < obj.y) {
	                    aniend(obj);
	                }

	                /*if (plot) {
	                    obj.ani.sarray[t] = obj.ani.s;
	                }*/
	                plotgraph(0, (obj.ani.minymin - obj.ani.s - 40) * pixel2m, t);

	            }
			
	            //obj.ani.t = obj.ani.t+0.01;
	            anit = t;
	            t = (performance.now() - runstart) / 1000;
	        }
	    });
	    if (end == 0) {
	        clearInterval(runfunc);
	        /*if (plot) {
	            startplot();
	            $(".chartrun").button('option', 'label', 'หยุดการสร้างกราฟ');
	        }*/
	    }
	    /*if (test) {
	        var testend = performance.now();
	        clearInterval(runfunc);
	        resetscene(true);
	        while (chart.series.length > 0) chart.series[0].remove(true);
	        return testend - teststart - ((testend - teststart) / 1.5);
	    }*/
	}
	} catch (e) { clearInterval(runfunc); }
	}
	if (test) {
	    return ani();
	} else {
	    runfunc = setInterval( ani, 1);
	}
}

function ruler(){}

var rulerstage = new Kinetic.Stage({
	container: 'rulercanvas',
	width: 568,
	height: 355
});
var rulerlayer = new Kinetic.Layer();

var rulertype = "เมตร";
var rulerconvert = 1;

function rulerdrawline (x1,y1,x2,y2) {
	var line = new Kinetic.Line({
		points: [x1,y1,x2,y2],
		stroke: "#00FFFF",
		strokeWidth: 5
	});
	line.data = Math.linear.getPointDistance(x1,y1,x2,y2,true);
	
	rulerlayer.add(line);
	rulerlayer.draw();
	line.on("mouseover",function () {
		$("#rulerresult").html(caldecimalround(line.data*pixel2m*rulerconvert)+" "+rulertype);
		line.setAttr("stroke","#FF0000");
		line.draw();
	});
	line.on("mouseout",function () {
		$("#rulerresult").html("นำเมาส์ไปวางบนเส้นเพื่อดูความยาว");
		line.setAttr("stroke","#00FFFF");
		line.draw();
	});
	
	return line;
}

function rulerdrawrect (centerx,centery,w,h) {
	var xmin = centerx-w/2;
	var ymin = centery-h/2;
	var xmax = centerx+w/2;
	var ymax = centery+h/2;
	
	var rect = new Kinetic.Line({
		points: [xmin, ymin, xmin, ymax, xmax, ymax, xmax, ymin],
		fill: 'rgba(0,0,0,0)',
		stroke: '#00FFFF',
		strokeWidth: 5,
		closed: true,
		draggable: true
	});
	
	rect.xmin = xmin;
	rect.ymin = ymin;
	rect.xmax = xmax;
	rect.ymax = ymax;
	
	rect.on("mouseover",function() {
		$("#rulerresult").html(caldecimalround(w*pixel2m*rulerconvert)+" x "+caldecimalround(h*pixel2m*rulerconvert)+" "+rulertype);
		rect.setAttr("stroke","#FF0000");
		try {rect.draw();} catch (e) {}
		
		$.each(rect.child,function(index,child) {
			child.setAttr("stroke","#FF0000");
			try {child.draw();} catch (e) {}
		});
	});
	
	rect.on("mouseout",function () {
		$("#rulerresult").html("นำเมาส์ไปวางบนเส้นเพื่อดูความยาว");
		rect.setAttr("stroke","#00FFFF");
		try {rect.draw();} catch (e) {}
		
		$.each(rect.child,function(index,child) {
			child.setAttr("stroke","#00FFFF");
			try {child.draw();} catch (e) {}
		});
	});
	
	rulerlayer.add(rect);
	rulerlayer.draw();
	
	var line1 = rulerdrawline(xmin,ymin,xmax,ymin);
	var line2 = rulerdrawline(xmin,ymin,xmin,ymax);
	var line3 = rulerdrawline(xmin,ymax,xmax,ymax);
	var line4 = rulerdrawline(xmax,ymin,xmax,ymax);
	
	rect.child = [line1,line2,line3,line4];
	
	return rect;
}

function rulerdrawbeam (beam) {
	var base = beam.getChildren()[0].clone();
	var basetop = rulerstage.getHeight()-50-(base.getAttr("radius")+1/2*base.getAttr("radius"));
	var basecenter = (rulerstage.getWidth()/2)+((beam.xmax-beam.xmin)/2)-(beam.xmax-beam.fulcrum);
	base.draggable(false);
	base.setX(basecenter);
	base.setY(rulerstage.getHeight()-50-1/2*base.getAttr("radius"));
	base.setAttr("fill","rgba(0,0,0,0)");
	base.setAttr("stroke","#00FFFF");
	base.on("mouseover",function () {
		$("#rulerresult").html("ความสูง: "+caldecimalround((base.getAttr("radius")+1/2*base.getAttr("radius"))*pixel2m*rulerconvert)+" "+rulertype);
		base.setAttr("stroke","#FF0000");
		h.setAttr("stroke","#FF0000");
		
		h.draw();
		base.draw();
	});
	base.on("mouseout",function () {
		$("#rulerresult").html("นำเมาส์ไปวางบนเส้นเพื่อดูความยาว");
		base.setAttr("stroke","#00FFFF");
		h.setAttr("stroke","#00FFFF");
		
		h.draw();
		base.draw();
	});
	var h = new Kinetic.Line({
		points: [basecenter,rulerstage.getHeight()-50,basecenter,basetop],
		stroke: "#00FFFF",
		strokeWidth: 5
	});
	rulerlayer.add(h);
	rulerlayer.add(base);
	
	var rect = rulerdrawrect(rulerstage.getWidth()/2,basetop-(beam.ymax-beam.ymin)/2,beam.xmax-beam.xmin,beam.ymax-beam.ymin);
	rect.child[2].remove();
	rect.child.push(rulerdrawline(basecenter,basetop,rect.xmax,basetop));
	rect.child.push(rulerdrawline(basecenter,basetop,rect.xmin,basetop));
	
	
	rulerlayer.draw();
}

function rulerdrawwedge (wedge) {
	var base = wedge.getChildren()[0].clone();
	var basetop = rulerstage.getHeight()-50-wedge.height;
	var basecenter = rulerstage.getWidth()/2
	base.draggable(false);
	base.points([basecenter-(wedge.width/2),basetop,basecenter+(wedge.width/2),basetop,basecenter,rulerstage.getHeight()-50]);
	base.setAttr("fill","rgba(0,0,0,0)");
	base.setAttr("stroke","#00FFFF");
	base.on("mouseover",function () {
		$("#rulerresult").html("ความกว้าง: "+caldecimalround(wedge.width*pixel2m*rulerconvert)+" "+rulertype+" ; ความสูง: "+caldecimalround(wedge.height*pixel2m*rulerconvert)+" "+rulertype);
		base.setAttr("stroke","#FF0000");
		h.setAttr("stroke","#FF0000");
		
		h.draw();
		base.draw();
	});
	base.on("mouseout",function () {
		$("#rulerresult").html("นำเมาส์ไปวางบนเส้นเพื่อดูความยาว");
		base.setAttr("stroke","#00FFFF");
		h.setAttr("stroke","#00FFFF");
		
		h.draw();
		base.draw();
	});
	var h = new Kinetic.Line({
		points: [basecenter,rulerstage.getHeight()-50,basecenter,basetop],
		stroke: "#00FFFF",
		strokeWidth: 5
	});
	rulerlayer.add(h);
	rulerlayer.add(base);
	
	
	rulerlayer.draw();
}

function rulerdrawslide (slide) {
	var width = slide.xend-slide.xstart;
	var height = stageh-60-slide.ystart;
	var centerx = rulerstage.getWidth()/2;
	var basey = rulerstage.getHeight()-50;
	var xstart = centerx-width/2;
	var xend = centerx+width/2;
	var ystart = basey-height;
	
	rulerdrawline(xstart,ystart,xstart,basey);
	rulerdrawline(xstart,basey,xend,basey);
	rulerdrawline(xend,basey,xstart,ystart);
	
	//slide.getChildren()[0].points([slide.xstart,slide.ystart,slide.xstart,stageh-60,slide.xend,stageh-60]);
	
}

function rulerdrawpulley (pulley) {
	var circle = new Kinetic.Circle({
		x: rulerstage.getWidth()/2,
		y: rulerstage.getHeight()/2,
		radius: pulley.r,
		stroke: '#00FFFF',
		fill: 'rgba(0,0,0,0)',
		strokeWidth: 4
	});
	var r = rulerdrawline(rulerstage.getWidth()/2,rulerstage.getHeight()/2,rulerstage.getWidth()/2+pulley.r,rulerstage.getHeight()/2);
	
	circle.on("mouseover",function () {
		$("#rulerresult").html("รัศมี: "+caldecimalround(pulley.r*pixel2m*rulerconvert)+" "+rulertype);
		circle.setAttr("stroke","#FF0000");
		r.setAttr("stroke","#FF0000");
		
		r.draw();
		circle.draw();
	});
	circle.on("mouseout",function () {
		$("#rulerresult").html("นำเมาส์ไปวางบนเส้นเพื่อดูความยาว");
		circle.setAttr("stroke","#00FFFF");
		r.setAttr("stroke","#00FFFF");
		
		r.draw();
		circle.draw();
	});
	
	rulerlayer.add(circle);
	
	rulerlayer.draw();
}

function rulerdraw () {
	var selected = getselectedobjects();
	/*$.each(selected,function(index,select) {
		objcreateanchor(select);
	});*/
	if (selected[0]) {
		switch (selected[0].type) {
			case "beam": rulerdrawbeam(selected[0]); break;
			case "slide": rulerdrawslide(selected[0]); break;
			case "object": rulerdrawrect(rulerstage.getWidth()/2,rulerstage.getHeight()/2,selected[0].width,selected[0].height); break;
			case "wedge": rulerdrawwedge(selected[0]); break;
			case "rope": rulerdrawline(rulerstage.getWidth()/2,rulerstage.getHeight()/2-selected[0].d/2,rulerstage.getWidth()/2,rulerstage.getHeight()/2+selected[0].d/2); break;
			case "pulley": rulerdrawpulley(selected[0]); break;
		}
	}
}

function openrulerdialog () {
	rulerlayer = new Kinetic.Layer();
	rulerstage.add(rulerlayer);
	$( "#rulerdialog" ).dialog({
		autoOpen: true,
		width: 600,
		modal: true,
		/*buttons: [
			{
				text: "Ok",
				click: function() {
					$( this ).dialog( "close" );
				}
			},
			{
				text: "Cancel",
				click: function() {
					$( this ).dialog( "close" );
				}
			}
		],*/
		resizeStop: function (event,ui) {
			rulerstage.setWidth(ui.size.width-32);
			rulerstage.setHeight(ui.size.height-90);
		},
		close: function (event,ui) {
			$("#rulerdialog").dialog("destroy");
			$("#rulerdialog").css("display","none");
			rulerlayer.remove();
		}
	});
	rulerdraw();
}

function resetoptiondialog () {
	$(".datainputg").val(g);
	$(".datainputratio").val(pixel2m);
	$(".datainputdecimalround").val(decimalround);
}

function openoptiondialog () {
	optiontemp = {
		g: g,
		ratio: pixel2m,
        decimalround: decimalround
	};
	$( "#optiondialog" ).dialog({
		autoOpen: true,
		width: 600,
		modal: true,
		buttons: [
			{
				text: "ตกลง",
				click: function() {
					g = optiontemp.g;
					pixel2m = optiontemp.ratio;
					decimalround = optiontemp.decimalround;
					resetoptiondialog();
					$(this).dialog("close");
					updatestatus();
				}
			},
			{
				text: "ยกเลิก",
				click: function() {
					resetoptiondialog();
					$( this ).dialog( "close" );
				}
			}
		],
		resizeStop: function (event,ui) {
			//rulerstage.setWidth(ui.size.width-32);
			//rulerstage.setHeight(ui.size.height-90);
		},
		close: function (event,ui) {
			$("#optiondialog").dialog("destroy");
			$("#optiondialog").css("display","none");
		}
	});
}

binddatainput();

function updateplottype() {
    $("#chartdialog .starter .option").val("null");
    $("#chartdialog .starter .option :not(.alloption)").css("display", "none");
    switch (currenttool) {
        case 1:
            $("#chartdialog .starter .option .slideoption").css("display", "block");
            break;
        case 2:
            $("#chartdialog .starter .option .beamoption").css("display", "block");
            break;
        case 3:
            $("#chartdialog .starter .option .pulleyoption").css("display", "block");
            break;
        case 4:
            $("#chartdialog .starter .option .wedgeoption").css("display", "block");
            break;
        case 5:
            $("#chartdialog .starter .option .wheeloption").css("display", "block");
            break;
        case 6:
            $("#chartdialog .starter .option .screwoption").css("display", "block");
            break;
    }
}


setTimeout(function () {
	$("#chartdialog .starter .option").val("null");
	$("#chartdialog .starter .option :not(.alloption)").css("display","none");
	var selected = getselectedobjects();
	selected = selected[0];
	if (selected) {
		switch (selected.type) {
			case "beam":
				$("#chartdialog .starter .option .beamoption").css("display","block");
				break;
			case "slide":
				//$("#chartdialog .starter .option").val("nooption");
				//$("#chartdialog .starter .option .slideoption").css("display","block");
				break;
			case "wedge":
				$("#chartdialog .starter .option .wedgeoption").css("display","block");
				break;
			case "pulley":
				$("#chartdialog .starter .option .pulleyoption").css("display","block");
				break;
			case "wheel":
				$("#chartdialog .starter .option .wheeloption").css("display","block");
				break;
		    case "screw":
		        $("#chartdialog .starter .option .screwoption").css("display", "block");
		        break;
			case "object":
				$("#chartdialog .starter .option .objoption").css("display","block");
				$("#chartdialog .starter .option .obj"+selected.instanceof.type+"option").css("display","block");
			case "rope":
				$("#chartdialog .starter .option .ropeoption").css("display","block");
				$("#chartdialog .starter .option .rope"+selected.instanceof.type+"option").css("display","block");
				break;
		}
	}
	//$("#chart").css("display", "none");
	$( "#chartdialog" ).dialog({
		autoOpen: true,
		width: ($(window).width() - 50) / 2,
		height: ($(window).height() - 190),
		modal: false,
		dialogClass: 'noTitleDialog',
		position: {
			my: 'right-25 top+15',
			at: 'right-25 top+15'
		},
		resizable: false,
		/*buttons: [
			{
				text: "เริ่ม",
				click: function () {
				    if (!onrun && !onplot) {
				        //$("#chart").css("display", "none");
				        graphinit(selected);
				        resetscene();
				        //console.log(selected.type);
				        switch (selected.type) {
				            case "object":
				                //console.log(selected.instanceof.type);
				                switch (selected.instanceof.type) {
				                    case "beam": run(true); break;
				                    case "slide":
				                        selected.ani = {};
				                        selected.ani.totalf = 0;
				                        $.each(selected.forces, function (index, f) {
				                            if (f.up) {
				                                selected.ani.totalf += f.force;
				                            } else {
				                                selected.ani.totalf -= f.force;
				                            }
				                        });

				                        var a = (((selected.weight / 1000 * g) * (Math.sin(selected.instanceof.angle * Math.PI / 180) - selected.instanceof.u * Math.cos(selected.instanceof.angle * Math.PI / 180))) - selected.ani.totalf) / (selected.weight / 1000) / pixel2m;
				                        if (a > 0) {
				                            var d = selected.dfromend - (selected.width / 2);
				                        } else {
				                            var slided = Math.linear.getPointDistance(selected.instanceof.xstart, selected.instanceof.ystart, selected.instanceof.xend, stageh - 60, true);
				                            var d = slided - (selected.dfromend - (selected.width / 2));
				                        }
				                        var t = Math.sqrt(Math.abs(d * 2 / a));

				                        console.log(d * 2 / a);

				                        startplot(t)
				                        break;
				                }
				                break;
				            case "rope":
				                //console.log(selected.instanceof.type);
				                switch (selected.instanceof.type) {
				                    case "pulley": case "wheel": run(true); break;
				                }
				                break;
				            case "beam": case "wedge": case "pulley": case "wheel": case "screw":
				                run(true); break;
				        }
				    } else if (onplot) {
				        onplot = false;
				    } else {
				        clearInterval(runfunc);
				        onrun = false;
				        $(".chartrun").button('option', 'label', 'หยุดการสร้างกราฟ');

				        startplot(anit);
				    }
					//$( this ).dialog( "close" );
				},
				'class':'chartrun'
			},
			{
				text: "ยกเลิก",
				click: function() {

					$( this ).dialog( "close" );
				}
			}
		],*/
		resize: function (event,ui) {
		    chart.reflow();
		},
		close: function (event,ui) {
			$("#chartdialog").dialog("destroy");
			$("#chartdialog").css("display", "none");
			$(window).resize();
		}
	});
	$(window).resize(function () {
	    //setTimeout(function () {
	        $("#chartdialog").dialog("option", "width", ($(window).width() - 50) / 2);
	        $("#chartdialog").dialog("option", "height", ($(window).height() - 190));
	        chart.setSize((($(window).width() - 50) / 2) - 30, ($(window).height() - 215), false);
	    //}, 10);
	});
	$(window).resize();
	//$(window).resize();
	setTimeout(function(){$(window).resize();},100);
},10);

var chart;

$(function () {
    chart = new Highcharts.Chart({
        chart: {
            renderTo: 'chart',
            type: 'spline',
            animation: false,
			zoomType: 'x'
            /*events: {
                load: function () {
					$(window).resize();
				}
            }*/
        },
        title: {
            text: 'กราฟ',
        },
        subtitle: {
            text: '',
        },
        xAxis: {
            lineColor: '#000000',
            lineWidth: 1,
			gridLineColor: '#C0C0C0',
			gridLineWidth: 1,
            minorGridLineColor: '#E0E0E0',
            minorGridLineWidth: 2,
            minorTickLength: 5,
			minorTickWidth: 1,
            minorTickInterval: 'auto',
			minorTickColor: "#000000",
			minorTickPosition: 'inside',
			tickLength: 0,
            labels: {
                style: {
                    color: '#000000'
                }
            },
            title: {
                enabled: true,
                text: 'เวลา [t] (วินาที)'
            },
        },
        yAxis: {
            title: {
                text: ''
            },
            plotLines: [{
                value: 0,
                width: 1,
                color: '#808080'
            }],
            events: {
				update: false,
			}
        },
        tooltip: {
            formatter: function () {
                var s = ["<b>วินาทีที่ " + this.x.toFixed(2) + "</b>"];

                $.each(this.points, function (i, point) {
                    s.push('<b>' + point.series.name + ':</b> ' +
                        caldecimalround(point.y));
                });

                return s.join("<br />");
				/*var ysuffix = "";
				switch ($("#chartdialog .starter .option").val()) {
					case "objslide0": ysuffix = "เมตรต่อวินาที"; break;
					case "objslide1":case "objslide2":case "wedge0":case "ropepulley0":case "ropepulley1":case "pulley0":
						ysuffix = "เมตร"; break;
					case "beam0": ysuffix = 'นิวตัน<span id="middot">⋅</span>เมตร'; break;
				}
				//console.log("<b>"+ytext+"</b>: "+this.y);
				return	"<b>วินาทีที่ "+this.x.toFixed(2)+"</b><br/>"+
						"<b>"+this.series.name+":</b> "+caldecimalround(this.y)+" "+ysuffix;*/
            },
            shared: true
        },
		plotOptions: {
			spline: {
				turboThreshold: 2000,
				lineWidth: 2,
				states: {
					hover: {
						enabled: true,
						lineWidth: 3
					}
				},
				marker: {
					enabled: false,
					states: {
						hover: {
							enabled : true,
							radius: 5,
							lineWidth: 1
						}
					}  
				}      
			},
			series: {
			    animation: false
			}
		},
        legend: {
            layout: 'vertical',
            align: 'right',
            verticalAlign: 'middle',
            borderWidth: 0
        },
		credits: {
			enabled: false
		}
    });
});
$(function () {
    $("#sidetoolbar").tooltip({
        position: {
            my: "left center",
            at: "right+5 center",
        }
    });
    $("#toptoolbar").tooltip({
        position: {
            my: "center top+5",
            at: "center bottom",
        }
    });
});
</script>
<script>

</script>
     
</body>
</html>
